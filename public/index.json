
[{"content":"","date":"2025 May 3","externalUrl":null,"permalink":"/categories/","section":"Categories","summary":"","title":"Categories","type":"categories"},{"content":" PART I: Context-Free Language # CFG: Context Free Grammar # CFG 定义为一个一个一个四元组：\\(G = (N, T, S, P)\\)\n\\(N\\): 非终结符 non-terminal 有限集 \\(T\\): 终结符 terminal 有限集。终结符和非终结符不重合。 \\(S\\): 作为起点的非终结符，\\(S \\in N\\) \\(P\\): production rules $$A \\to a$$ \\(A \\in N\\), 是非终结符；\\(a \\in (N \\cup T)^*\\), 是某些终结符和非终结符的连接（或者单个符） CFG 的 Derivation: \\(\\Rightarrow_G\\) # Intro # 推导 (deviation) 是 CFG 的运算法则，用来从几个 production rules 推导到更多的 CFL.\n推导方式： Assumption: \\(A \\to \\gamma\\) Deviation: \\(\\alpha A \\beta ~\\Rightarrow_G ~\\alpha \\gamma \\beta\\)（可以省略下标 G, 如果语境比较清晰） 跳步骤、连续推导的符号：\\(\\Rightarrow^*\\) 这就是“上下文无关”的体现：assumption 所包含的性质不随这个单元的前面连接的东西 (\\(\\alpha\\)) 或者后面连接的东西 (\\(\\beta\\)) 的出现与否而改变\nCFL: Context Free Language # $$ L(G) = {w \\in T^*:~S \\Rightarrow^*w} $$\nCFL语言中的词是非终结符的集合，并且都能根据 CFG 的文法推导出来。\nLeft-Most Deviation \\(\\Rightarrow_{lm}\\) # 最左推导\n每一步推导都只把左边的 non-terminal 换成 terminal\n最右推导 \\(\\Rightarrow_{rm}\\) 类似喵\nParse Trees / Syntax Trees 语法树 # 上文中，给定一个终结符串，用最左推导构成的语法树。\n推导其实是建立语法树的过程。 语法树可以通过根据 production rules，从某个非终结符开始，进行一定顺序的推导（如最左/最右推导）构成 树中每个叶都是终结符，每个节点都是非终结符。 Ambiguity # Ambiguity 描述了 CFG 的一种性质：如果 CFG 构成的 CGL 中的一个字符串可以有多个不同的语法树，那么这个 CFG 是有二义性的；如果 CFL 的所有字符串都有唯一树的与之对应，那这个 CFG 就没有二义性。 Inherent Ambiguity # 有些 CFL 只有 ambiguous 的语法，也就是说对于这些语言我们无法消除其二义性。 并没有一个明确的算法来判定一个语法是否有二义性！ 并没有一个公式化的算法来消除所有能消除二义性的 CFL 的二义性！ (try to) Eliminating Ambiguity # 有几个尝试消除其二义性的方法\n1. Priority\u0026amp;Associativity # 提高某些运算符的优先级，先推导它们。\n2. 重写文法 # 比如 if-else 的二义性\nUsing Ambiguous Grammar (生肉) # Given that we cannot always eliminate ambiguity, just use it! We will discuss how we use ambiguous grammar in the next Lecture when introducing specific parsing techniques All regular languages are context-free languages. # PART II: Push-Down Automata # Intro # 来，复习一下 CFL\n来，复习一下Reg Lang和DFA/NFA的等价性\nRegular language = DFA/NFA Context-free language = PDA = \\(NFA + Stack (z0)\\) AI: PDA（Pushdown Automata，下推自动机）是一种理论计算模型，它扩展了有限自动机（DFA/NFA）的能力，通过引入一个栈（stack）来存储和检索信息。这个名字中的“push-down”（下推）源于其核心操作：在处理输入符号时，PDA 可以将符号推入栈（push）或从栈中弹出符号（pop），从而实现对输入的动态记忆和回溯能力。这种栈结构使得 PDA 能够处理具有嵌套结构或递归性质的语言，例如括号匹配或嵌套的函数调用，而这些是有限自动机无法处理的。下推自动机是研究上下文无关语言（CFG）的重要工具，它在编译原理中用于语法分析阶段，帮助解析程序代码的结构，确保其符合语言的语法规则。\n形式化定义：七元组 # 一个 NPDA/PDA 可以定义为以下形式\n$$ P = (Q, \\Sigma, \\Gamma, \\delta, q_0, z_0, F) $$\n\\(Q\\) 状态的有限集 \\(\\Sigma\\) 输入字符串的字母表 \\(\\Gamma\\) 可以入栈出栈的字母表 \\(\\delta\\) trasition function \\(Q \\times ( \\Sigma \\cup {\\epsilon} )\\times \\Gamma \\to 2^{Q \\times\\Gamma^*}\\) 左边：输入的字符和入栈的字符； 右边：到达的状态和目前在栈内的字符 (的连接)。Non-destiministic, 所以是幂集。 \\(q_0\\) 初始状态 \\(z_0\\) 栈内的初始字符 (stack start symbol) \\(F\\) final state 的集合，\\(F \\subseteq Q\\) Instantaneous Description # Instantaneous Description 是对 PDA 在某个状态的描述： $$ (q, w, \\gamma) $$\n\\(q\\): 当前状态 \\(w\\): 剩余没有进入状态机的输入 \\(\\gamma\\): 栈中剩下的内容 针对一个转换函数： $$(q, \\alpha) \\in \\delta(p, a, X)$$\n\\(p\\) 是之前的状态，\\(q\\) 是转换函数之后的状态 \\(X\\) 是要出栈的元素, \\(\\alpha\\) 是入栈的函数 \\(a\\) 是下一步的输入 我们有： $$ (p, aw, X\\beta) \\vdash_M(q, w, \\alpha\\beta) $$\nLanguage of PDA # PDA 既有入栈出栈，又有状态转移，因此有两种角度来定义 language, 并且可以证明二者其实等价。\nAcceptance by final states # 一个 string 能被 PDA 接受，如果\n所有的输入都被消耗 最终可以停留在一个 final state PDA 定义的语言自然是这些 stirng 的集合： $$ L(M) = {w \\in \\Sigma^: (q_0, w, z_0) \\vdash^_M (q_f, \\epsilon, u),~~ q_f \\in F, ~u \\in \\Gamma^*} $$ Acceptance by empty stack # 一个 string 能被 PDA 接受，如果\n所有的输入都被消耗 最终栈是空的 PDA 定义的语言自然是这些 stirng 的集合： $$ L(M) = {w \\in \\Sigma^: (q_0, w, z_0) \\vdash^_M (\\textcolor{red}{q}, \\epsilon, \\textcolor{red}{\\epsilon}),~~ \\textcolor{red}{q \\in Q}} $$ 等价？ # 如果一个语言可以通过某种 PDA 通过最终状态接受，那么也存在另一个 PDA 可以通过空栈接受相同的语言，反之亦然。\nPART III: CFG = PDA # 1. \\(CFG \\subseteq PDA\\) # 如何从 CFG 构造一个 PDA?\n对于个 CFG 四元组，我们可以构造一个等价的 PDA 七元组；令这个 PDA： $$ ({q}, T, T \\cup N, \\delta, q, S, \\varnothing) $$ 解析：\n只有一个状态，并且没有 final state. 也就是说这个 PDA 是 Acceptance by empty stack 的； 输入都是终结符，栈中的既可以是终结符也可以是非终结符； 初始状态时栈中只有一个作为起点的非终结符。 CFG 的规则如何向 PDA 的规则转化？\n对一个目标是空栈的 PDA, 状态不要紧，我们只关注 PDA 栈的变化：从栈顶开始 peek,\n如果栈中遇到一个非终结符 \\(A\\)，就把他 pop 出来，再入栈 CFG 中的 production rules 规定的推导 \\(A \\to \\gamma\\) 中的 \\(\\gamma\\): $$ \\delta(q, \\epsilon, A) = {(q, \\beta): A \\to \\beta \\in P} $$ 如果遇到一个终结符 \\(a\\)，就直接把他读取并弹出: $$ \\delta(q, a, a)= {(q, \\epsilon)} $$ 2. \\(PDA \\subseteq CFG\\) # 如何从一个（可能有点特殊的）PDA 构造 CFG?\n我们还是只讨论 Acceptance by empty stack 的 PDA, 为了方便我们忽略最终状态。对任何一个 PDA, 写成 \\((Q, \\Sigma, \\Gamma, \\delta, q_0, z_0, \\varnothing)\\), 我们找到一个 CFG 写作 $$ CFG(N, \\Sigma, P, S),~~~ N={S} \\cup {N_{p X q}:p, q \\in Q, X \\in \\Gamma} $$ 解析：\n定义非终结符集合：非终结符不仅包括起点的 non-terminal, 还包含 PDA 中任意一个路径，即把这个路径连同起点终点构造成一个包含了其特征的非终结符，叫做 \\(N_{pXq}\\), 代表从 p 状态转移到 q 状态，弹出 \\(X\\). 定义 production rules： 对于 PDA 任意一个状态 \\(q\\)，存在 rule: 初始的非终结符 \\(\\to\\) 从 \\(q_0\\) 到 \\(q\\)、弹出 \\(z_0\\) 剩下空栈的路径 $$ \\forall p \\in Q: S \\to N_{q_0 z_0 p} \\in P $$ 对于一个消耗输入 \\(a\\), 弹出 \\(X\\) 不压入任何字符的路径，存在 rule: $$ (q, \\epsilon) \\in \\delta(p, a, X) \\Rightarrow N_{pXq}\\to a \\in P $$ 对于一个消耗 \\(a\\), 弹出 \\(X\\) 并压入 \\(X_1X_2 \\ldots X_k\\) 的路径，存在 rule: $$ (q, X_1X_2\\ldots X_k) \\in \\delta(p,a,X) \\Rightarrow N_{pXp_k} \\to aN_{qX_1p_1}N_{p_1X_2p_2}\\ldots N_{p_{k-1}X_kp_k} \\in P $$ 例子：\nDPDA: Deterministic PDA # 在任何时刻，对于给定的输入符号或栈顶符号（这俩任意一个一样都不行），最多只有一个转移动作。\nCFL 一定有 PDA, 但是不一定有 DPDA. DPDA 的语言是没有二义性的！ PART IV: Properties of CFL # CLosure Properties # 给定两个 CFL \\(L_1\\) 和 \\(L_2\\)（对应的 CFG 起始非终结符分别是 \\(S_1\\) \\(S_2\\)）, 以下的语言也是 CFL：\n\\(L_1 \\cup L_2\\) \\(L_1L_2\\) \\(L^*_1\\) \\(L_1^R\\) Intersection of CFL # \\(L_1 \\cap L_2\\) 证明：取 \\(L_1={a^nb^nc^m},L_2={a^nb^mc^m}\\)，则 \\(L_1 \\cap L_2 = {a^nb^nc^n}\\), 这不显然不是 CFL? \\(\\overline{L_1}\\) 证明：\\(L_1 \\cap L_2 = \\overline{\\overline{L_1} \\cup \\overline{L_2}}\\) 如果非一定是 CFL, 那前面的交就一定是了。 \\(L_1-L_2\\) 证明：\\(\\overline{L_1} = \\Sigma^* - L_1\\) 但是一个 CFL 和一个 RL 的交是 CFL: 构建一个模拟 CFL 的 NPDA、一个模拟 RL 的 DFA, 把他们交起来\nApplication of the Properties # 为什么 \\(a^nb^n\\) 是 CFL? 因为能把他构造成一个很基础的 PDA.\nDecidable Properties # CFG（上下文无关文法）的可判定性质（Decidable Properties）是指可以通过算法来确定其结果的性质。\n1. 给定一个 CFG, CFL 是否为空？ # 检查起始非终结符是否没有被使用，或者无效使用 \\(e.g.~S\\to S\\)\n2. 给定一个 CFG, CFL 是否无限？ # 算法：\n移除无用的非终结符：\n无用的非终结符是指那些既不能推导出终结符字符串，也不能出现在任何可推导出终结符字符串的产生式中的非终结符。通过移除这些非终结符，可以简化文法，同时不影响其生成的语言。\n移除单元产生式和空产生式：\n单元产生式是指形如 \\(A \\rightarrow B\\) 的产生式，其中 \\(A\\) 和 \\(B\\) 都是单个非终结符；空产生式是指形如 \\(A \\rightarrow \\epsilon\\) 的产生式。移除这些产生式可以进一步简化文法，同时便于后续分析。\n构建剩余非终结符的依赖图：\n依赖图是一个有向图，其中每个节点代表一个非终结符，边 \\(A \\rightarrow B\\) 表示在某个产生式中，非终结符 \\(A\\) 可以直接或间接推导出非终结符 \\(B\\)。通过构建依赖图，可以直观地表示非终结符之间的推导关系。\n检查依赖图中是否存在环：\n如果依赖图中存在环，说明存在至少一个非终结符可以通过自身或一系列非终结符的推导最终回到自身。这种循环结构表明文法可以无限地生成字符串，因此生成的语言是无限的。如果没有环，则生成的语言是有限的。\n通过上述步骤，可以判断一个 CFG 生成的语言是否是无限的。\n3. 给定一个 CFG, 某个字符串是否属于其 CFL? # 算法 1：构造 NPDA, 看看 NPDA 能否接受这个 String 算法 2：the CYK algorithm (O (n3)) Undecidable Properties # CFG 是否有二义性 CFG 是否有不可避免的二义性 两个 CFG 的交是否为空 两个 CFG 是否等价 某个 CFG 是否可以等价为 \\(\\Sigma^*\\) PART V: Pumping Lemma for CFL # Chomsky Normal Form # 一种 CFG 的标准形式。如果 CFG 的所有 production rule 都是如下形式：\n\\(A \\to BC\\) \\(A \\to a\\) \\(S\\to\\epsilon\\) 其中 \\(a\\) 是终结符，\\(ABC\\) 是非终结符，\\(S\\) 是起始非终结符 那么这个 CFG 就是 CNF. 语法树是一个二叉树。 # 上下文无关语言的泵引理 # 定义： 泵引理可以用于证明一个语言不是上下文无关语言（CFL）。它指出，如果一个语言是上下文无关的，那么所有足够长的字符串都必须满足某些“可泵性”条件。\n泵引理的陈述： 设 \\(L\\) 是一个上下文无关语言（CFL）。则存在一个常数 \\(p\\)（称为泵长度），使得对于任何字符串 \\(s \\in L\\)，只要 \\(|s| \\geq p\\)，就可以将 \\(s\\) 分解为 \\(s = uvwxy\\)，满足以下条件：\n\\(|vx| \\geq 1\\)（即 \\(v\\) 和 \\(x\\) 至少有一个非空） \\(|vwx| \\leq p\\)（即 \\(vwx\\) 的长度不超过 \\(p\\)） 对于所有 \\(i \\geq 0\\)，字符串 \\(uv^iwx^iy\\) 仍然属于 \\(L\\)。 解释：\n条件 1：确保至少有一个部分可以被“泵”（即重复）。 条件 2：限制“可泵部分”的长度，使其在某个局部范围内。 条件 3：无论“泵”的次数多少，生成的字符串仍然属于语言 \\(L\\)。 应用： 泵引理主要用于证明某个语言不是上下文无关的。如果一个语言违反了泵引理的条件，则该语言不是上下文无关语言。\n示例： 假设 \\(L = {a^n b^n c^n \\mid n \\geq 1}\\)。假设 \\(L\\) 是上下文无关的，那么存在一个泵长度 \\(p\\)。选择字符串 \\(s = a^p b^p c^p\\)，根据泵引理，\\(s\\) 可以被分解为 \\(uvwxy\\)，满足上述条件。然而，无论怎样分解，都无法保证 \\(uv^iwx^iy\\) 仍然属于 \\(L\\)（因为 \\(a\\)、\\(b\\) 和 \\(c\\) 的数量必须严格相等）。因此，\\(L\\) 不是上下文无关语言。\n注意：\n泵引理只能用来证明一个语言不是上下文无关的，不能用来证明一个语言是上下文无关的。 对于某些语言，可能需要尝试多个字符串才能找到违反泵引理的反例。 ","date":"2025 May 3","externalUrl":null,"permalink":"/posts/compiler-ch-4-1/","section":"Posts","summary":"编译原理笔记","title":"Chapter 4-1 CFL \u0026 PDA","type":"posts"},{"content":"","date":"2025 May 3","externalUrl":null,"permalink":"/","section":"Hitchhiker","summary":"","title":"Hitchhiker","type":"page"},{"content":"","date":"2025 May 3","externalUrl":null,"permalink":"/posts/","section":"Posts","summary":"","title":"Posts","type":"posts"},{"content":"","date":"2025 May 3","externalUrl":null,"permalink":"/series/","section":"Series","summary":"","title":"Series","type":"series"},{"content":"","date":"2025 May 3","externalUrl":null,"permalink":"/categories/studybase/","section":"Categories","summary":"","title":"StudyBase","type":"categories"},{"content":"","date":"2025 May 3","externalUrl":null,"permalink":"/tags/","section":"Tags","summary":"","title":"Tags","type":"tags"},{"content":"","date":"2025 May 3","externalUrl":null,"permalink":"/tags/%E7%AC%94%E8%AE%B0/","section":"Tags","summary":"","title":"笔记","type":"tags"},{"content":"","date":"2025 May 3","externalUrl":null,"permalink":"/tags/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/","section":"Tags","summary":"","title":"编译原理","type":"tags"},{"content":"","date":"2025 May 3","externalUrl":null,"permalink":"/series/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E7%AC%94%E8%AE%B0/","section":"Series","summary":"","title":"编译原理笔记","type":"series"},{"content":" PART I: Regular Language # 定义 # 如果一个语言 \\(L\\) 能有一个 DFA/NFA \\(M\\) ，使得 \\(L = L(M)\\)，则 \\(L\\) 是 regular language\n封闭性 Closure Properties # 两个 regular language，他们的并、交、非、连接、逆、kleene star 也是 regular 的。 Regular language is closed under union, intersection, Reversal, complement, concatenation, and Kleene star\n\\(L_1 \\cup L2\\) # \\(L_1L_2\\) # \\(L_1^R\\) # \\(L_1^*\\) # \\(\\overline{L_1}\\) # \\(L_1 \\cap L_2\\) # 好像瞪不出来了？ 🤓👆事实上，可以用前面的形式拼接而成，因为德摩根定律： $$ L_1 \\cap L_2 = \\overline{\\overline{L_1} \\cup \\overline{L_2}} $$\nPART II: Regular Expression (regex) # Regex definition # Regex 被递归地定义，以下的称为 regex：\nPrimitive regex 空集（∅）：表示空语言，即不包含任何字符串 空字符串（ε）：表示只包含空字符串的语言 单个字符：a ∈ Σ，表示只包含字符 a 的语言 扩展法则：给定的两个 regex, 它们的： 并集（Union）：如果 R 和 S 是 regex，则 R | S 也是 regex 连接（Concatenation）：如果 R 和 S 是 regex，则 RS 也是 regex 闭包（Kleene Star）：如果 R 是 regex，则 \\(R^*\\) 也是 regex R 是 regex, (R) 也是 regex 例如： a*：表示所有由字符 a 组成的字符串，包括空字符串。 a|b：表示只包含字符 a 或字符 b 的字符串。 (ab)*：表示所有由 ab 重复零次或多次组成的字符串。 Language defined by regex # \\(L (\\varnothing) = \\varnothing;~ L (\\epsilon) = {\\epsilon};~ L (a) = {a}\\) 扩展： \\(L (r_1|r_2) = L (r_1) \\cup L(r_2)\\) \\(L (r_1r_2) = L (r_1) L(r_2)\\) \\(L (r_1^) = (L (r_1))^\\) \\(L ((r_1)) = L (r_1)\\) 判断正则表达式等价 # Two regex are equivalent if they represent the same language 也就是说分别话这两个 regex 代表的 language 对应的状态机，判断等价即可。\nLaws of regex # 和离散数学中的许多概念相似（虽然你离散数学没做笔记），regex 具有：\n交换性 commutativity \u0026amp; 结合性 associativity 元 Identity 和零化子 Annihilator 分配律 distributive 和自反 idempotent 封闭性 Closure Regex 与 regular language 等价 # 1. Regex-\u0026gt;reg lang # Any regex represents a regular language.\n回忆 regular language 的定义，发现上面的话可以等价成\n任何正则表达式 (regex) 都可以对应一个 NFA/DFA.\n转化方法 # Primitive regex 可以用 NFA/DFA 表示： Regex 的扩展法则也能用 NFA/DFA 表示，怎么证明？ 回忆我们之前是如何通过拼接构造新的自动机来证明 reg Lang 在并、连接、kleene star 下是封闭的。这分别对应 regex 的三个（其实有四个，只不过最后一个是废话）扩展法则。 总结 把目标 regex 用语言表示且化成最简形式； 把最小单元的 primitive regex 的状态机画出来; 根据语言的并/连接/star, 把这些基础的状态机拼接起来 例子 2. Reg Lang-\u0026gt;regex # Any regular language can be expressed by a regex.\n和前面的套路一样，可以理解成\n任何一个 DFA 都可以被一个 regex 表示。\n转化方法 # 把每个状态用距离小于等于一的状态表示 化简 PART III: Lexical Analysis # 词法分析究竟如何工作？\n为词素（如数字、变量等）编写正则表达式； 基于 regex, 构建 NFA-\u0026gt;化简成 DFA 如果一开始不是 DFA-\u0026gt;将 DFA 最简化 将源代码视作一个长长的输入字符串 将输入字符串与构建好的 DFA 匹配，细节上让多个 DFA 共同工作，需要的特性有 DFA 有不同的优先级，先匹配\u0026hellip; 再匹配\u0026hellip; 这样 贪婪匹配，总是匹配符合正则表达式的最长字符串 PART IV: Pumping Lemma # 泵引理。\n假设存在一个 regex, 对应的状态机称作 \\(M\\)，对应的语言称作 \\(L\\)。 如果一个字符串 \\(w \\in L\\), 并且 \\(w\\) 足够长——具体来说，如果 \\(w\\) 长到 \\(|w| \\geq m\\)，其中 m 是状态机的状态总数，那么 w 输入状态机所走过的路径中必定含有重复路径，也就是走过了不止一次的路径。\n这个重复的路径就是\u0026quot;泵\u0026quot;，容易知道可以在 \\(w\\) 的基础上构造字符串，字符串中这个“泵”可以重复无数次，重复后得到的字符串一定还是在这个正则表达式对应的语言中（因为还是可以被状态机 \\(M\\) 所接受）。\n严格定义 # 如果\n\\(L\\) 是一个无限的正则表达式，则 一定存在一个正整数 \\(m\\), 对任何 \\(w \\in L\\) 并且 \\(|w| \\geq m\\) 的字符串 \\(w\\)， 我们都能把 \\(w\\) 写成 $$w=xyz$$ 其中 \\(|xy| \\leq m\\) 且 \\(|y| \\geq 1\\), 使得 $$w_i=xy^iz \\in L$$ 其中 \\(i \\geq 1\\). 这个定义中 y 就是可以不同重复的泵，只要找到的特殊字符串足够长，就可以认为这个 y 存在。\n有什么用？ # 可以用该引理的逆否命题来证明一个字符串/语言并非 regular:\n对于任何一个正整数 \\(m\\), 如果存在 \\(w \\in L\\) 使得 \\(|w| \\geq m\\) 自行挑一组 \\(xyz\\)，使得 \\(w = xyz, y \\neq \\epsilon, |xy| \\leq m\\) 如果还能找到一个 k, 使得 \\(xy^kz \\notin L\\) 那么就能证明 \\(L\\) 并非正则！ 例证 # 例如，考虑语言 \\(L = {a^n b^n | n ≥ 0}\\)，即由相同数量的 \\(a\\) 和 \\(b\\) 组成的字符串。假设这个语言是正则的，那么根据泵引理，存在一个泵长度 \\(p\\)。选择一个字符串 \\(w = a^p b^p\\)，它显然属于 \\(L\\)。根据泵引理，\\(w\\) 可以分解为 \\(w = xyz\\)，其中 \\(|xy| ≤ p\\)，\\(|y| ≥ 1\\)。因为 \\(w\\) 的前 \\(p\\) 个字符都是 \\(a\\)，所以 \\(y\\) 必然只包含 \\(a\\)。假设 \\(y = a^k\\)，其中 \\(k ≥ 1\\)。\n现在，考虑字符串 \\(xy^2z = a^{(p+k)} b^p\\)。这个字符串显然不属于 \\(L\\)，因为它包含的 \\(a\\) 的数量多于 \\(b\\) 的数量；但是根据泵引理他又应该是属于 \\(L\\) 的。因此语言 \\(L\\) 不是正则的。\n","date":"2025 May 3","externalUrl":null,"permalink":"/posts/compiler-ch-3-2/","section":"Posts","summary":"编译原理笔记","title":"Chapter 3-2 Lexical Analysis","type":"posts"},{"content":" PART I: Math Preliminaries # String and apphabet # language: 一个字符串组成的集合：cat, dog, ... string: 字符 (letter) 序列，字符从 alphabet (如 \\(\\sum = {a, b, c, d, \u0026hellip;, z}\\)) 而来。\n对一个简单的 alphabet \\(\\sum = {a, b}\\)，\nStrings: a, b, aab, \u0026hellip;. Language：string 全集的任意子集；或者说 Kleene Star 的任意子集 String opeartion # 1. Concatenation # $$ w_1 = aabb $$ $$ w_2 = bbaa $$ $$ w_1w_2 = aabbbbaa $$\n2. Reverse # $$ w = abcd $$ $$ w^R=dcba $$\n3. Length # $$w = a_1a_2a_3a_4$$ $$|w| = 4$$\nEmpty String # \\(\\epsilon\\) \\(|\\epsilon| = 0\\) \\(\\epsilon aabb = aabb\\)，也就是说可以放在任何地方\nSub-string # Substring: 子串 Prefix and suffix: \\(w = uv\\), u 是 prefix, v 是 suffix, u/v 可以是 \\(\\epsilon\\)\nPower, Kleene Star, Plus # Power # \\(w^n\\) 是 n 个 w 拼接在一起 \\(w^0\\) 必是 \\(\\epsilon\\) Kleene Star # 对一个简单的 alphabet \\(\\sum = {a, b}\\) Kleene Star \\(\\sum^{\\ast}\\) 是所有用 alphabet 组成的 string 的集合，包括空集 Language 的新定义：Kleene star 的任意非空子集，包括 \\({ \\epsilon }\\)\nPlus # \\(\\sum^+\\) = \\(\\sum^{\\ast}\\) - \\({ \\epsilon }\\)\nOperation on Languages # 并，交，减 补 Complement: 等于 Kleene Star 减去自身 Reverse: Concatenation: 有点像 笛卡尔积 实例： Power Star-Closure Positive-Closure PART II: Deterministic Finite Automata # Intro # 有限状态机的输入是一个 String, 经过有限状态机后，输出\u0026quot;Accept\u0026quot;或\u0026quot;Reject\u0026quot;.\n最终停在 final state 就 accept, 否则 reject. 比如，对于输入 abb，这个状态机的运行： 可以看出每一步的走向都只有一种情况，所以叫 Deterministic. DFA 的表示 # 五元组表示 \\(Q\\): 有限数量的状态，如 \\(q_1, q_2, \\ldots\\) \\(\\sum\\): 有限集，元素是字符，是有限机的输入 \\(\\sigma\\) : 转换方程，可以列表格表示 \\(q\\): 当前状态 \\(a\\): 字母，下一次输入 \\(q\u0026rsquo;\\): 下一个状态 \\(q_0\\): 起始状态, 唯一 \\(F\\): final state 的集合。 转换方程有扩展版的，此时 \\(\\sum\\) 变成了其 Kleene Star, 也就是输入多个字符，one at a time\n用 DFA 定义语言 # 能够被某个状态机 \\(M = (Q, \\sum, \\theta, q_0, F)\\) 接受的 language （也就是说，language 的 string 作为输入进入 DFA 能停在 final state）被记作 $$ L(M) = {w \\in \\Sigma^* | \\sigma^*(q_0, w) \\subseteq F } $$\nDFA Minimization # 先把非 final state 放进一个集合，final state 放在一个集合 查看每个集合中的每一个状态接受某个输入后的下一个状态，如果这个集合接受相同的输入进入的下一个状态都在一个集合，就合法；否则不合法，要把不合法的状态放进新的集合。 重复这个操作，知道无法再细分。 这种算法的平均复杂度： $$ \\Omega(n \\log \\log n) $$\nDFA Bi-Simulation # 一种用于分析和比较两个 DFA 行为等价性的技术。Bi-Simulation 的核心思想是通过建立一种关系，使得两个 DFA 的状态在某种意义上“行为相似”，即一个 DFA 的行为可以模拟另一个 DFA 的行为，反之亦然。\n在 DFA 的上下文中，Bi-Simulation 关系通常用于证明两个 DFA 是否接受相同的语言, 即，\\(L (M_1) = L(M_2)\\)\n算法 # 等价条件 # 给一个输入字符串，让要进行比较的两个有限机共同运作，让 $$M_1 到达 finalstate$$ 和 $$M_2 到达 finalstate$$ 是等价条件，则认为二者等价。\n具体步骤 # 将两个DFA 的初始状态配成一个 state pair 让这个 pair 接受所有可能的输入，分别产生新的 state pair; 观察产生的 state pair, 如果满足上面提价的等价条件，则继续，否则肯定不等价； 将产生的新的（和之前不重复的）state pair 重复第二部，接受输入继续产生 state pair\u0026hellip;. 直到无法产生新的 state pair, 如果始终满足等价条件，则两个 DFA 确实等价。 概括地说，如果存在一个双模拟关系，使得两个 DFA 的初始状态相关联，并且这种关系能够扩展到所有可达状态，则这两个 DFA 被认为是等价的。\nPART III: Non-deterministic Finite Automata # Intro # 之前说过，输入确定，DFA 的每一步都是只有一种情况的，本节的状态机就有不止一种。\n如上例，aa只要有一条路径能走到 final state, 就可是说是被 accepted 了。 NFA 的表示 # \\(\\epsilon ～transition\\): 不消耗任何输入也能进行的状态转换。\n仍然用五元组表示，但区别：\n\\(\\Sigma \\cup {\\epsilon}\\): \\(\\epsilon\\) 也能作为状态转换的输入 \\(\\sigma:~Q\\times (\\Sigma \\cup {\\epsilon}) \\vdash 2^Q\\) 第二个参数的定义域多了 \\(\\epsilon\\) \\(2^Q\\) 就是 \\(P(Q)\\), 是 Q 的幂集，表示最后的状态不再是确定的一个元素，而是多个可能的状态组成的集合 \\(\\epsilon ~closure\\): \\(\\epsilon\\) -closure (q) returns all states q can reach via \\(\\epsilon\\)-transitions, including q itself\nNFA 转换方程的扩展形式 # $$ \\sigma:~Q\\times\\Sigma^*\\vdash2^Q $$\n\\(q\u0026rsquo;\\) 能被扩展形式的转换方程 \\(\\sigma^*(q, w)\\) 接受，当且仅当： \\(q\\) 经过 w 的输入到达q'' \\(q\u0026rsquo;\\) 是 \\(\\epsilon\\) -closure (q) 中的元素。 用 NFA 定义语言 # 能够被某个 NFA \\(M = (Q, \\sum \\cup {\\epsilon}, \\theta, q_0, F)\\) 接受的 language 记作 $$ L(M) = {w \\in \\Sigma^* | \\sigma^*(q_0, w) \\cap F \\neq \\varnothing} $$ 也就是说，只要最终能到的所有状态中包含最终状态，就能算作被 NFA 接受。\nDFA = NFA # DFA只是一个特殊形式的NFA NFA 可以用特定算法转换成 DFA，转换前后的 language 是等价的。 子集构造法：from NFA to DFA # DFA 的初始状态：DFA 的初始状态进行 \\(\\epsilon\\) 闭包计算后得到的状态集合作为 DFA 的初始状态。 从初始状态开始，对NFA的每个状态进行： 找出其对某个输入（say a）的所有转移后的状态； 对这些状态再进行闭包运算，得到的所有状态构成一个集合，这个集合就是 DFA 经过输入 a 后转移到的状态。 继续找其他的输入（当然不包括 \\(\\epsilon\\)）得到 DFA 的其他状态转移情况。 最后得到 DFA。 符号化说明： 🌰： 在子集构造法中，DFA的每个状态都是NFA状态的集合。因此，如果NFA有n个状态，那么DFA的状态数量最多可以是 \\(2^n\\) 个，因为n个状态的所有可能子集数量是 \\(2^n\\)。\n对于每一个n，都存在一些n-状态的NFA，其中从初始状态集合出发，可以到达所有可能的状态子集。这意味着在最坏情况下，转换后的DFA将恰好有\\(2^n\\)个状态。\n由于在最坏情况下DFA的状态数量是\\(2^n\\)，因此转换过程的时间复杂度是\\(Θ(2^n)\\)。这表示转换过程的时间随着NFA状态数量的增加而指数增长。\n当将NFA转换为DFA时，没有保证转换后的DFA会比NFA更小。实际上，由于DFA状态是NFA状态的集合，因此在最坏情况下，DFA的状态数量会远大于NFA。\n","date":"2025 May 3","externalUrl":null,"permalink":"/posts/compiler-ch-3-1/","section":"Posts","summary":"编译原理笔记：了解有限状态机","title":"Chapter 3-1 Finite Automata","type":"posts"},{"content":"","date":"2025 May 3","externalUrl":null,"permalink":"/tags/%E6%9C%89%E9%99%90%E7%8A%B6%E6%80%81%E6%9C%BA/","section":"Tags","summary":"","title":"有限状态机","type":"tags"},{"content":" Part I Compilers # 一、基本了解：Compiler, Interpreter 和 Linker # 什么是 Compiler？ # 编译器的作用就是将源语言转换为目标语言，以便计算机能够执行。 一些编译器（称作 transpiler）还尝试把源语言转换成另一种目标语言，比如热门的 C-\u0026gt;Rust 什么是 Interpreter? # 逐条读取源代码，并一条条的翻译成机器语言并执行。 不会生成独立的目标代码，每次执行都要从头翻译，这个意义上，效率比编译器低 一个特殊的变体：Java 什么是 Linker? # 将多个文件（Compilation units 说是）组合成一个文件——可执行文件或者库 编译与链接的流程： 其中， -O1 中的 -O 是编译优化选项； -l 是链接选项。 二、编译器的具体编译流程 # IR 指的是中间表示 (intermediate representation)\n前端：读取文件信息（词法语法语义）；将代码转化成 IR 中端：“从 IR 到 IR”, 是 machine-independent optimization 后端：也有machine-independent optimization，还有最终目标代码的生成 Front End # Lexical analysis # 词法分析\nFind lexemes according to patterns, and create tokens\n将文件中的字符（根据预订的 pattern）分割成一个个语素 Lexeme, 创造一个个 token\nLexeme: 人类理解的一个字符串 Pattern: 表征字符串的性质，通常是 regex. 如果没有 pattern 匹配到文件中的某个内容，就产生 Lexical Errors Token: 词法分析中的输出，源代码的基本单元： Token=\u0026lt;token-class, attribute\u0026gt; 如 INTEGER, 42, L_PAREN, ( Syntax Analysis # 语法分析\nCreate the (abstract) syntax tree (AST)\n创建语法树。\nSymbol table, symbol tree…\nSemantic Analysis # 语义分析\n主要任务是检查程序的语义是否正确，即使程序通过了语法分析，也不一定意味着它是有效的。例如： 检查变量是否已声明。 检查类型是否匹配。 检查操作符是否适用于操作数。 添加语义信息：语义分析会为抽象语法树（AST）的每个节点添加语义信息，这些信息通常包括： 类型信息：变量、表达式和函数的类型。 作用域信息：变量和函数的作用域。 符号表信息：符号表中存储的变量和函数的定义。 IR Generation # 根据 AST 生成 IR, 如三地址码\nMiddle End # 中端针对 IR, 提供了和机器无关的优化. IR 相对源码，提供了更易处理的标准形式；相对目标码，提供了其机器无关的上层抽象。（机器无关：和硬件处理和指令集差异无关，任何 ISA 通用）\nBack End # Translate IR to machine code (Meanwhile) Perform machine-dependent optimization\nInstruction Selection 不同格式风格的指令各有优劣。 Register Allocation 寄存器比内存快得多，但是个数有限，所以分配寄存器要有一定的优化策略，这不是乱搞的 Instruction Scheduling (指令调度) 目标机器通常提供支持指令级并行（Instruction-Level Parallelism, ILP）的硬件资源，如多个执行单元、超标量架构或多发射处理器。指令调度的目标是生成能够充分利用这些并行资源的机器代码，从而提高程序的执行效率。 Part || Tools # 看你的 PPT 去,,\nProgramming languages # 函数式编程（Functional Programming） # 定义\n函数式编程仅包含函数，不改变状态或数据。每个函数都是独立的，不依赖于外部状态。 也就是说，不存在全局变量了。 函数式编程的核心是通过组合和应用函数来解决问题。\n函数可以作为参数传递，也可以返回新的函数。\n以下是关于**逻辑编程（Logic Programming）**的笔记，结合了你提供的例子：\n逻辑编程（Logic Programming） # 1. 定义 # 逻辑编程是一种基于数学逻辑的编程范式，通过声明事实（Facts）和规则（Rules）来描述问题，而不是直接指定解决问题的步骤。\n2. 核心概念 # 事实（Facts）：表示已知的、不可改变的陈述。 规则（Rules）：表示基于事实推导出新结论的逻辑关系。 查询（Queries）：通过逻辑推理引擎验证或推导出新的事实。 3. 示例 # 以下是一个逻辑编程的简单示例，使用了事实、规则和查询：\n事实（Facts） # rainy(\u0026#34;Nanjing\u0026#34;). rainy(\u0026#34;Beijing\u0026#34;). cold(\u0026#34;Beijing\u0026#34;). 声明了两个城市（南京和北京）的天气情况。rainy(\u0026quot;Nanjing\u0026quot;) 表示南京是多雨的，rainy(\u0026quot;Beijing\u0026quot;) 和 cold(\u0026quot;Beijing\u0026quot;) 表示北京是多雨且寒冷的。\n规则（Rules） # snowy(C) :- rainy(C), cold(C). 规则表示如果一个城市既多雨又寒冷，那么它就是下雪的。snowy(C) 是结论，rainy(C) 和 cold(C) 是前提条件。\n查询（Queries） # ?- snowy(X). 查询所有满足 snowy 条件的城市。逻辑引擎会根据事实和规则进行推理，输出符合条件的城市。\n特点 # 逻辑编程是声明式的，程序员只需要声明事实和规则，而不需要指定具体的执行步骤。 逻辑引擎会自动进行推理，根据事实和规则推导出新的结论。 逻辑编程适合解决复杂的逻辑问题，如推理、规划和知识表示。 以下是关于**类型系统（Type Systems）**的笔记，严格按照要求格式化：\nType Systems 类型系统 # Static Typing / Dynamic Typing # 静态类型: 在编译时获取类型信息。 例如 Java 中， String str = \u0026ldquo;Hello\u0026rdquo;; // 被静态存储 str = 5; // 报错，因为str类型已经被staticcally(编译时)确定\n- 动态类型: 在运行时获取类型信息。 Python 中， ```python str = \u0026#34;Hello\u0026#34; # 此时是string str = 5 # 变成整型，不会报错 Strong Typing / Weak Typing # 强类型: 类型区分严格，不允许隐式类型转换。 Python 中， str = 5 + \u0026ldquo;hello\u0026rdquo; #报错，python其实是强类型\n注意 py 是动态类型，编写时不要显示标注类型，但*不是弱类型*！ - 弱类型: 类型区分较宽松，允许隐式类型转换。 Php: ```php $str = 5 + \u0026#34;hello\u0026#34; # string 在php中被隐式cast成0,所以结果是0 Scoping 作用域 # Static Scoping（静态作用域） # 根据程序的源代码结构来确定变量的作用域\n变量的作用域在编译时确定，与程序的结构（如函数嵌套）相关。 函数中引用的变量在定义时就绑定到其最近的外部作用域。 便于代码理解和优化，现代语言（如 C、Python、JavaScript 等）大多采用静态作用域。 Dynamic Scoping（动态作用域） # 根据程序的 运行时状态（调用栈） 来确定变量的作用域。\n变量的作用域在运行时确定，与函数调用顺序相关。 函数中引用的变量绑定到最近的调用环境中的变量。 更灵活，但难以理解和优化，主要用于某些脚本语言（如 Emacs Lisp）。 Function Invocation # Virtual Functions 虚函数 # 虚函数是在基类中声明的成员函数，可以被派生类重新定义 override。 虚函数允许实现多态（Polymorphism），即通过基类指针或引用调用函数时，会调用实际对象的版本。 虚函数必须是non-private、non-static且non-final。 在 Java 中，任何非私有、非静态且非 final 的方法都是虚函数，可以被 overridden. 示例代码 # 1. void add(List\u0026lt;Integer\u0026gt; list, Integer y) { 2. list.add(y); // 调用的是ArrayList.add()还是LinkedList.add()？ 3. } 在上述代码中，List 是一个接口，ArrayList 和 LinkedList 是其实现类。 调用 list.add(y) 时，实际调用的方法取决于 list 的运行时类型（即实际对象的类型），而不是其声明类型。这是虚函数（多态）的典型行为。 ","date":"2025 May 3","externalUrl":null,"permalink":"/posts/compiler-ch-1-and-2/","section":"Posts","summary":"编译原理笔记：了解编译器设计的大致流程，和构建编译器的相关工具","title":"Chapter 1\u00262 Intro to Compilers\u0026Tools","type":"posts"},{"content":"","date":"2025 May 3","externalUrl":null,"permalink":"/tags/%E6%A6%82%E8%BF%B0/","section":"Tags","summary":"","title":"概述","type":"tags"},{"content":"","date":"2025 April 29","externalUrl":null,"permalink":"/tags/free/","section":"Tags","summary":"","title":"Free","type":"tags"},{"content":"","date":"2025 April 29","externalUrl":null,"permalink":"/tags/server/","section":"Tags","summary":"","title":"Server","type":"tags"},{"content":"","date":"2025 April 29","externalUrl":null,"permalink":"/categories/techplay/","section":"Categories","summary":"","title":"TechPlay","type":"categories"},{"content":"","date":"2025 April 29","externalUrl":null,"permalink":"/tags/vps/","section":"Tags","summary":"","title":"Vps","type":"tags"},{"content":"","date":"2025 April 29","externalUrl":null,"permalink":"/tags/%E8%96%85%E7%BE%8A%E6%AF%9B/","section":"Tags","summary":"","title":"薅羊毛","type":"tags"},{"content":"","date":"2025 April 29","externalUrl":null,"permalink":"/tags/%E6%95%99%E7%A8%8B/","section":"Tags","summary":"","title":"教程","type":"tags"},{"content":"写下这些文字的时候，本站正处于⭐寄掉⭐的状态——服务器使用校园网， 而用curl认证的校园网时不时会断开（据室友经验,是不小心连上了无线网导致的）；ssh又发电了，可能是因为我的环境从宿舍变成了教室， 主机的ip地址从10.xx变成172.26.xxx，这就导致我无法连接还在宿舍的服务器来配置网络。1为了让网站不那么鸡肋，同时满足折腾的精神需求， 我决定在这次近代史课上尝试配置一个云主机，并记录过程与遇到的问题。\n开始配置之前 # 关于VPS # VPS（Virtual Private Server，虚拟专用服务器）是使用虚拟化技术，在一台物理服务器上划分出的多个独立“虚拟服务器”。 每个 VPS 都拥有自己的操作系统、存储空间、CPU、内存和网络接口，就像一个小型的云服务器。\nVPS 通常运行在大型云平台（如 微软的 Azure、亚马逊的AWS、阿里云）之上，这些平台拥有大量的公网 IP 资源。云平台为了让用户能远程连接 VPS（如 SSH、RDP），通常会： 为每台 VPS 自动或手动分配一个 公网 IPv4 地址，并且 公网 IP 直接绑定到该 VPS 的网络接口，或通过 NAT 映射，也就变相地获得了一个公网ip地址。\n选择提供商 # 作为新手并不要求VPS服务的质量和硬件配置有多好，所以只会寻找免费服务，参考了这篇博客文章。 总结下来，只有甲骨文(Oracle)可以永久白嫖服务器，但是注册非常麻烦，并且需要一个支持国际货币的 visa 卡，实在懒得办了。 而 Azure 服务会为学生提供每年 100 美金的免费额度，只需要一个 edu 邮箱就可以申请，所以我选择了Azure.\n配置 Azure # 主要参考这篇文章。这篇文章已经非常详细了，配置过程中没有遇到任何问题（除了云主机涨价），至福！\nOMG It\u0026rsquo;s CSDN💩!\n推荐搭配净化 CSDN 脚本使用；希望你点开链接之前，这篇文章不会成为 💩VIP💩 专属。\n下一步……? # 没想到获取一个ip地址这么容易，也没想到服务器连不上的原因这么抽象1。总之，既然两个主机都挺稳定的， 可以考虑让这两个服务器一起负责为这个网站服务，做负载均衡。\nWell actually🤓👆, 以上整个推论都是错误的。在写完这篇后回寝室发现，内外网都断了——但只是因为我中午不小心碰了一下主机导致网线松动， 没有连上。\u0026#160;\u0026#x21a9;\u0026#xfe0e;\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n","date":"2025 April 29","externalUrl":null,"permalink":"/posts/configuring-vps/","section":"Posts","summary":"记录了自己决定搞一个免费的云主机玩玩的全过程，以及一些科普和吐槽。","title":"我是学生，送我——使用Microsoft Azure配置云主机","type":"posts"},{"content":"","date":"2025 April 29","externalUrl":null,"permalink":"/tags/%E4%BA%91%E4%B8%BB%E6%9C%BA/","section":"Tags","summary":"","title":"云主机","type":"tags"},{"content":"","date":"2025 April 29","externalUrl":null,"permalink":"/tags/%E6%8A%98%E8%85%BE/","section":"Tags","summary":"","title":"折腾","type":"tags"},{"content":"在这个各种自动化工具都发展的十分健全的年代，建立静态托管的个人网站已经不再是一种非常geek的事情了，这甚至不比重装windows系统困难多少。建站的花费也是微乎其微：如果不执着于网站的域名，也不介意网站时不时无法访问，你甚至不需要花一分钱来达成这个目的；你需要的只是一个能够正常运行、受得了长时间开机的电脑罢了。不过，本站的建立还是比直接把html挂在github page要多出几步的，所谓折腾的乐趣大概就在这里吧（笑）。\n自底向上的Overview # 本次建站中，我选择在本机Arch Linux系统上使用Blowfish主题的Hugo生成网站项目，再将其public文件夹下的网页文件上传至Debian系统的香橙派主机的/var/www/hugo上；香橙派作为服务器，Nginx监听80端口进行静态网页内容的调取，作为反向代理1；Cloudflare建立与服务器的隧道，提供外界访问的接口，作为第二个反向代理；最后，使用Nameslio购买该域名，并将DNS配置为Cloudflare提供的DNS。\n于是，当你的鼠标点击https://hhikr.moe后，上文提到的这些部件就会像一组齿轮一般，反向地连锁运行；而对于目前的这个网站，各种交互只不过是通过这组齿轮，间接地访问服务器中的 html 文件罢了。\n自顶向下的Breakdown # 1. Nameslio: 域名的购买 # 了解的不多，也没什么好说的。正常的.com域名五六十就可以买到，廉价的.xyz/.top域名更是可以夸张到两位数的价格就可以连续租用十年，.moe在 Nameslio 上价格较贵，但价格还是不到一百一年。\n域名也可以在某些网站上免费申请，不过可能面对审核周期长、难以备案等问题。\n2. Cloudflare: 大善人的余裕 # 因为moe而多花几十已经够亏了，再去买个ip地址未免过于破费。而 Cloudflare 正好就可以实现不用自己买公网ip就可以实现外界访问的入站。它主要做了两件事：\n提供 DNS 服务器； 使用 Tunnel 服务，将服务器中的内容通过 Tunnel 向世界敞开。 cloudflare在本机浏览器中的配置几乎都是跟着这个视频来的（跟着做到建立tunnel之前），所以省略具体的配置内容，看视频吧。\n一些科普 # cloudflare是如何做到不需要提供公网ip也能使入站流量导向hhikr.moe?\n当然，不可能做到“不需要ip地址”；cloudflare的tunnel技术提供了所谓的内网出站2的功能。 所谓“内网出站”，就是香橙派像浏览器访问网页一样，自己去连接外部服务器，这种连接在校园网、家庭宽带等没有公网IP的环境下是允许的3，不需要路由器做特殊设置（比如端口映射）。 建立隧道后，Cloudflare服务器就能通过这条香橙派主动打通的通道，把世界各地的访问流量安全地传给香橙派，从而实现即使没有公网IP，网站也可以被所有人访问。\n换句话说，香橙派用 cloudflared 程序， 主动去连接 Cloudflare 的服务器（出站连接）， 这条连接就是一个持久保持的加密通道（Tunnel，隧道）， Cloudflare那边可以通过这条隧道“推送”用户的请求过来。\nCloudflare 为托管的网站免费提供了许多服务，可谓是互联网带善人了，有空会多研究研究。（这算开坑吗？）\n3. Nginx \u0026amp; Orange Pi # 通过ssh服务连接至香橙派主机，在其上进行 Cloudflare 服务、Nginx托管的相关配置。\n连接ssh遇到的问题 # 校园网环境内，服务器的ssh连接遇到了严重的连接问题，并且十分玄学，具体表现是我的主力电脑和手机（使用Termmius软件）都无法连接ssh，舍友的手机秒连， 但是舍友的电脑一样连接不上。但是给香橙派插上主机后连接就没有任何问题了。只能推断是对不同段ip,校园网的管理员配置不一样，因为插网线后内网ip从10开头变成了 172开头（但是主力电脑上的ip一直是10开头）。\n配置流程 # 传输脚本 # 编写脚本，将本地的文件传输至服务器。使用rsync指令，这一部分也是需要ssh的。\n#!/bin/bash # ===================== 配置区 ===================== # DEFAULT_USER=\u0026#34;orangepi\u0026#34; DEFAULT_HOST=\u0026#34;114.514.19.19\u0026#34; REMOTE_DIR=\u0026#34;/var/www/hugo\u0026#34; DEPLOY_LOG=\u0026#34;$HOME/.hugo_deploy.log\u0026#34; URL=\u0026#34;https://hhikr.moe\u0026#34; # ================================================== # echo \u0026#34;🌐 当前配置：\u0026#34; echo \u0026#34;用户：$DEFAULT_USER\u0026#34; echo \u0026#34;IP地址：$DEFAULT_HOST\u0026#34; echo \u0026#34;远程目录：$REMOTE_DIR\u0026#34; echo \u0026#34;\u0026#34; # —— 是否更换 IP 地址？—— read -p \u0026#34;当前的 IP 是 ${DEFAULT_HOST}，是否更换？(y/N): \u0026#34; change_ip if [[ \u0026#34;$change_ip\u0026#34; =~ ^[Yy]$ ]]; then read -p \u0026#34;请输入新的 IP 地址: \u0026#34; new_ip if [[ -n \u0026#34;$new_ip\u0026#34; ]]; then DEFAULT_HOST=\u0026#34;$new_ip\u0026#34; echo \u0026#34;✅ IP 更新为 $DEFAULT_HOST\u0026#34; else echo \u0026#34;⚠️ 未输入新 IP，继续使用默认 IP：$DEFAULT_HOST\u0026#34; fi fi # —— 输入 SSH 密码 —— read -s -p \u0026#34;请输入 SSH 密码（不会显示）: \u0026#34; SSHPASS echo \u0026#34;\u0026#34; echo \u0026#34;\u0026#34; echo \u0026#34;📁 检查远程目录：$REMOTE_DIR\u0026#34; read -p \u0026#34;是否继续部署到该目录？(Y/n): \u0026#34; confirm_dir if [[ \u0026#34;$confirm_dir\u0026#34; =~ ^[Nn]$ ]]; then read -p \u0026#34;请输入新的远程目录路径: \u0026#34; REMOTE_DIR fi echo \u0026#34;🚧 开始构建 Hugo 项目...\u0026#34; hugo 2\u0026gt; hugo-error.log if [ $? -ne 0 ]; then echo \u0026#34;❌ Hugo 构建失败！错误日志保存在 hugo-error.log\u0026#34; exit 1 fi echo \u0026#34;📤 正在上传静态文件到 ${DEFAULT_USER}@${DEFAULT_HOST}:${REMOTE_DIR} ...\u0026#34; sshpass -p \u0026#34;$SSHPASS\u0026#34; rsync -avz --delete -e \u0026#34;ssh -o StrictHostKeyChecking=no\u0026#34; ./public/ ${DEFAULT_USER}@${DEFAULT_HOST}:${REMOTE_DIR} | tee -a \u0026#34;$DEPLOY_LOG\u0026#34; if [ $? -ne 0 ]; then echo \u0026#34;❌ 上传失败！请检查网络或 SSH 权限\u0026#34; exit 1 fi echo \u0026#34;\u0026#34; echo \u0026#34;✅ 部署成功！你的网站应该已经上线：$URL\u0026#34; # —— 是否打开浏览器访问？（仅本机有图形界面时建议开启）—— if command -v xdg-open \u0026amp;\u0026gt; /dev/null; then read -p \u0026#34;是否现在在浏览器中打开网站？(Y/n): \u0026#34; open_browser if [[ ! \u0026#34;$open_browser\u0026#34; =~ ^[Nn]$ ]]; then xdg-open \u0026#34;$URL\u0026#34; fi fi echo \u0026#34;📜 部署日志已记录：$DEPLOY_LOG\u0026#34; 由于我几乎不会写bash脚本，这个脚本是由llm生成的，可能有很奇怪的地方。好在 It just works.\nNginx配置 # 配置Nginx，监听localhost的80端口，托管静态网页。\n# 1. 创建站点目录 sudo mkdir -p /var/www/hugo sudo chown -R $USER:$USER /var/www/hugo # 2. 写入配置 sudo nvim /etc/nginx/sites-available/hugo # 3. 启用配置 sudo ln -s /etc/nginx/sites-available/hugo /etc/nginx/sites-enabled/ # 建立静态连接将“可用网站”放在“已激活网站”下，所以Nginx就会从/etc/nginx/sites-enabled/寻找可以启动的网站。 sudo nginx -t # -t代表test,用于测试Nginx配置是否正确 sudo rm /etc/nginx/sites-enabled/default # 删除默认界面，否则你可能会看到Nginx的默认界面而不是你的网站 sudo systemctl reload nginx # 刷新服务，启动nginx Nginx配置文件实例：\nserver { # 监听端口。为什么是80？因为cloudflare tunnel走的是http！ listen 80; server_name hhikr.moe; root /var/www/hugo; # 首页。 index index.html; # 如果路径存在，返回文件；否则返回 404 location / { try_files $uri $uri/ =404; } } Cloudflare配置 # 安装：根据官方教程安装。下面是官网提供的debian系安装流程。 curl -fsSL https://pkg.cloudflare.com/cloudflare-main.gpg | sudo gpg --dearmor -o /usr/share/keyrings/cloudflare-main.gpg echo \u0026#34;deb [signed-by=/usr/share/keyrings/cloudflare-main.gpg] https://pkg.cloudflare.com/cloudflared bookworm main\u0026#34; | \\ sudo tee /etc/apt/sources.list.d/cloudflared.list sudo apt update sudo apt install cloudflared -y 登陆并创建tunnel # 登录 Cloudflare cloudflared tunnel login # 它会打开一个浏览器链接，在上面登录你的 Cloudflare 账户。 # 创建 tunnel cloudflared tunnel create hhikr-moe-tunnel # 会生成一个 .json 文件，路径如 /home/orangepi/.cloudflared/634b00...json 配置 Cloudflare Tunnel，映射到本地 Nginx mkdir -p ~/.cloudflared nano ~/.cloudflared/config.yml 配置文件这么写：\ntunnel: hhikr-moe-tunnel credentials-file: /home/orangepi/.cloudflared/634b00...json ingress: - hostname: hhikr.moe service: http://localhost:80 - service: http_status:404 将tunnel与域名绑定，并启动tunnel cloudflared tunnel route dns hhikr-moe-tunnel hhikr.moe # 暂时启动，有输出，用于查看运行状态或debug cloudflared tunnel run hhikr-moe-tunnel # 永久启动，作为service运行，开机就会自动运行。 sudo cloudflared service install 至此，网站应该就可以正常运作了。おめでとう🎉\n反向代理是一种服务器，它位于客户端和目标服务器之间，客户端以为自己直接连接的是目标服务器，但实际上所有请求都先到反向代理，由它再转发到真正的服务器；这样可以隐藏真实服务器地址、实现负载均衡、缓存内容，加速访问，提高安全性。\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n在网络通信里，出站（Outbound）指的是从你的设备主动发起请求到外部，入站（Inbound）指的是外部主动连接到你的设备。\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n没有公网ip的设备可以进行出站访问，但不能处理入站请求。\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n","date":"2025 April 28","externalUrl":null,"permalink":"/posts/building-website/","section":"Posts","summary":"第一次建站的一些经验。","title":"记录我的第一次建站","type":"posts"},{"content":"","date":"2025 April 28","externalUrl":null,"permalink":"/tags/%E5%BB%BA%E7%AB%99/","section":"Tags","summary":"","title":"建站","type":"tags"},{"content":"","date":"2025 April 28","externalUrl":null,"permalink":"/tags/%E9%A6%99%E6%A9%99%E6%B4%BE/","section":"Tags","summary":"","title":"香橙派","type":"tags"},{"content":"hey! (招手.gif)1\n早就想做个人网站了，但是一直摆着……不过还是做出来了，感谢朋友半天建站完成的push喵。\n软件工程二年生，正在被编译原理折磨。可能什么文章都会放网站上,专业/语言/音乐的学习笔记、观影杂谈、或者是捣鼓一些自己感兴趣的东西，比如尝试不同的linux发行版和桌面环境、捣鼓网站新功能之类\n这篇文章将会是一个时间胶囊，记录网站在今后的沿革。目前网站还在测试阶段，并没有什么有趣的东西，预计劳动节会做个差不多。所以首先，来看看我建站都用了哪些相关的技术栈吧（超简单的来着）。\n第一次修改，ver 0.20250428\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n","date":"2025 April 28","externalUrl":null,"permalink":"/posts/time-machine/","section":"Posts","summary":"引导之始。","title":"时间胶囊","type":"posts"},{"content":"","externalUrl":null,"permalink":"/authors/","section":"Authors","summary":"","title":"Authors","type":"authors"}]