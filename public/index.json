
[{"content":"","date":"2025 May 3","externalUrl":null,"permalink":"/categories/","section":"Categories","summary":"","title":"Categories","type":"categories"},{"content":"","date":"2025 May 3","externalUrl":null,"permalink":"/","section":"Hitchhiker","summary":"","title":"Hitchhiker","type":"page"},{"content":"","date":"2025 May 3","externalUrl":null,"permalink":"/tags/os/","section":"Tags","summary":"","title":"OS","type":"tags"},{"content":"","date":"2025 May 3","externalUrl":null,"permalink":"/posts/","section":"Posts","summary":"","title":"Posts","type":"posts"},{"content":"","date":"2025 May 3","externalUrl":null,"permalink":"/series/","section":"Series","summary":"","title":"Series","type":"series"},{"content":"","date":"2025 May 3","externalUrl":null,"permalink":"/categories/studybase/","section":"Categories","summary":"","title":"StudyBase","type":"categories"},{"content":"","date":"2025 May 3","externalUrl":null,"permalink":"/tags/","section":"Tags","summary":"","title":"Tags","type":"tags"},{"content":"","date":"2025 May 3","externalUrl":null,"permalink":"/tags/%E7%AC%94%E8%AE%B0/","section":"Tags","summary":"","title":"笔记","type":"tags"},{"content":"","date":"2025 May 3","externalUrl":null,"permalink":"/series/%E7%AC%94%E8%AE%B0-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/","section":"Series","summary":"","title":"笔记-操作系统","type":"series"},{"content":"","date":"2025 May 3","externalUrl":null,"permalink":"/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/","section":"Tags","summary":"","title":"操作系统","type":"tags"},{"content":"\n\n","date":"2025 May 3","externalUrl":null,"permalink":"/posts/os-1/","section":"Posts","summary":"操作系统笔记","title":"操作系统笔记-未命名","type":"posts"},{"content":"","date":"2025 May 3","externalUrl":null,"permalink":"/series/%E7%AC%94%E8%AE%B0-%E6%95%B0%E6%8D%AE%E5%BA%93/","section":"Series","summary":"","title":"笔记-数据库","type":"series"},{"content":" 修改基本表的语法 # ALTER TABLE \u0026lt;表名\u0026gt; [ ADD[COLUMN] \u0026lt;新列名\u0026gt; \u0026lt;数据类型\u0026gt; [完整性约束] ] [ ADD \u0026lt;表级完整性约束\u0026gt; ] [ DROP [COLUMN] \u0026lt;列名\u0026gt; [CASCADE | RESTRICT] ] [ DROP CONSTRAINT \u0026lt;完整性约束名\u0026gt; [RESTRICT | CASCADE] ] [ ALTER COLUMN \u0026lt;列名\u0026gt; \u0026lt;数据类型\u0026gt; ]; 各部分解释 # \u0026lt;表名\u0026gt;：要修改的基本表的名称。\nADD[COLUMN] \u0026lt;新列名\u0026gt; \u0026lt;数据类型\u0026gt; [列级完整性约束]：用于向表中添加一个新列，可以同时指定该列的数据类型和完整性约束条件。\nADD \u0026lt;表级完整性约束\u0026gt;：用于向表中添加新的表级完整性约束条件，例如主键、外键、唯一性约束等。\nDROP [COLUMN] \u0026lt;列名\u0026gt; [CASCADE | RESTRICT]：用于删除表中的列。\nCASCADE：如果该列被其他对象（如外键、视图等）引用，则自动删除这些依赖对象。 RESTRICT：如果该列被其他对象引用，则拒绝删除该列。 DROP CONSTRAINT 子句：\nDROP CONSTRAINT \u0026lt;完整性约束名\u0026gt; [RESTRICT | CASCADE]：用于删除表中指定的完整性约束条件。 RESTRICT：如果该约束被其他对象依赖，则拒绝删除。 CASCADE：自动删除依赖该约束的所有相关对象。 ALTER COLUMN 子句：\nALTER COLUMN \u0026lt;列名\u0026gt; \u0026lt;数据类型\u0026gt;：用于修改表中已有列的定义，包括数据类型等。注意，某些数据库系统可能不支持直接修改列名。 示例解释 # 示例 3.8：向Student表增加“入学时间”列 # ALTER TABLE Student ADD S_entrance DATE;\n解释：向Student表中添加一个名为S_entrance的新列，数据类型为DATE（日期型）。 注意：不管表中是否已有数据，新增的列默认值为空值。 示例 3.9：将年龄的数据类型由字符型改为整数 # ALTER TABLE Student ALTER COLUMN Sage INT;\n解释：将Student表中名为Sage的列的数据类型从字符型（假设原类型为CHAR或VARCHAR）修改为整数类型（INT）。 注意：在修改数据类型时，需要确保表中已有的数据符合新的数据类型要求，否则会报错。 示例 3.10：增加课程名称必须取唯一值的约束条件 # ALTER TABLE Course ADD UNIQUE(Cname);\n解释：向Course表中添加一个表级完整性约束，要求Cname列的值必须唯一。 删除基本表的语法及示例解释 # 删除基本表的语法 # DROP TABLE \u0026lt;表名\u0026gt; [RESTRICT | CASCADE];\n各部分解释 # \u0026lt;表名\u0026gt;：要删除的基本表的名称。 RESTRICT：限制性删除。 如果该表被其他表的约束（如外键）引用，或者表上有依赖的对象（如视图、索引、触发器等），则不允许删除该表。 这种方式更安全，防止误删除导致数据完整性问题。 CASCADE：级联删除。 删除该表时，同时删除所有依赖该表的对象，包括视图、索引、触发器等。 这种方式更彻底，但需要谨慎使用，因为可能会导致大量相关对象被删除。 示例解释 # 示例 3.11：删除Student表 # DROP TABLE Student CASCADE; 解释：删除 Student 表，并且级联删除所有依赖该表的对象，如索引、视图、触发器等。 注意：使用 CASCADE 时，表及其所有相关对象都会被删除，操作不可逆。 示例 3.12：删除表时的选择 # 假设存在一个视图 IS_Student，其定义如下：\nCREATE VIEW IS_Student AS SELECT Sno, Sname, Sage FROM Student WHERE Sdept = \u0026#39;IS\u0026#39;; 使用 RESTRICT：\nDROP TABLE Student RESTRICT; 解释：尝试删除 Student 表，但由于视图 IS_Student 依赖于该表，删除操作会失败，并报错： ERROR: cannot drop table Student because other objects depend on it 注意：RESTRICT 选项会阻止删除任何有依赖关系的表，从而保护数据完整性。 使用 CASCADE：\nDROP TABLE Student CASCADE; 解释：删除 Student 表，并且级联删除所有依赖该表的对象，包括视图 IS_Student。 注意：执行后会提示： NOTICE: drop cascades to view IS_Student 表示视图 IS_Student 也被自动删除。 总结 # 使用 DROP TABLE 删除表时，RESTRICT 和 CASCADE 选项的选择取决于是否需要保留依赖对象： 如果需要保留依赖对象，使用 RESTRICT。 如果需要彻底删除表及其所有依赖对象，使用 CASCADE。 索引 # 索引的目的 # 建立索引的目的：加快查询速度。 由数据库管理员或表的拥有者建立。 由关系数据库管理系统自动完成维护。 关系数据库管理系统自动使用合适的索引作为存取路径，用户不必也不能显式地选择索引。 常见索引类型 # 顺序文件上的索引 B+树索引 散列（hash）索引 位图索引 建立索引 # 语句格式 # CREATE [UNIQUE] [CLUSTER] INDEX \u0026lt;索引名\u0026gt; ON \u0026lt;表名\u0026gt;(\u0026lt;列名\u0026gt;[\u0026lt;次序\u0026gt;][,\u0026lt;列名\u0026gt;[\u0026lt;次序\u0026gt;]...]); 各部分解释 # \u0026lt;表名\u0026gt;：要建索引的基本表的名字。 索引可以建立在该表的一列或多列上，各列名之间用逗号分隔。 \u0026lt;次序\u0026gt;：指定索引值的排列次序，升序：ASC，降序：DESC。缺省值：ASC。 UNIQUE：此索引的每一个索引值只对应唯一的数据记录。 CLUSTER：表示要建立的索引是聚簇索引。 示例 3.13：为学生-课程数据库中的表建立索引 # CREATE UNIQUE INDEX Stusno ON Student(Sno); CREATE UNIQUE INDEX Coucno ON Course(Cno); CREATE UNIQUE INDEX SCno ON SC(Sno ASC, Cno DESC); Student 表按学号升序建唯一索引。 Course 表按课程号升序建唯一索引。 SC 表按学号升序和课程号降序建唯一索引。 修改 / 删除索引 # 修改索引 # ALTER INDEX \u0026lt;旧索引名\u0026gt; RENAME TO \u0026lt;新索引名\u0026gt;;\n示例 3.14：将 SC 表的 SCno 索引名改为 SCSno # ALTER INDEX SCno RENAME TO SCSno; 删除索引 # DROP INDEX \u0026lt;索引名\u0026gt;;\n示例 3.15：删除 Student 表的 Stusname 索引 # DROP INDEX Stusname; 删除索引时，系统会从数据字典中删去有关该索引的描述。 数据字典 # 数据字典是关系数据库管理系统内部的一组系统表，它记录了数据库中所有定义信息： 关系模式定义 视图定义 索引定义 完整性约束定义 各类用户对数据库的操作权限 统计信息等 关系数据库管理系统在执行 SQL 的数据定义语句时，实际上就是在更新数据字典表中的相应信息。 ","date":"2025 May 3","externalUrl":null,"permalink":"/posts/database-3/","section":"Posts","summary":"数据库笔记","title":"第3章：SQL——关系数据库标准语言","type":"posts"},{"content":"","date":"2025 May 3","externalUrl":null,"permalink":"/tags/%E6%95%B0%E6%8D%AE%E7%AE%A1%E7%90%86%E5%9F%BA%E7%A1%80/","section":"Tags","summary":"","title":"数据管理基础","type":"tags"},{"content":" 关系，关系模式，关系数据库 # 关系 # 一些数学上的概念的回忆，和在数据库系统内的含义\nDomain Cartesian Product Relation： \\(R_n\\) \\(R\\): 关系名 \\(n\\): 关系的目/度 Attribute 属性: 每一列的名字，比如学号、分数… 属性数=目数 Tuple 元组: 集合中的一个元素 Component 分量：元素中的一个值 码 # 候选码 # 若关系中的某一属性组的值能唯一地标识一个元组，而其子集不能，则称该属性组为候选码。 简单情况：候选码只包含一个属性。 最极端情况：关系模式的所有属性组是候选码，称为全码（All-key）。 主码 # 若一个关系有多个候选码，则选定其中一个为主码。\n主属性与非主属性 # 候选码的所有目的属性属性称为主属性（Prime Attribute）。 不包含在任何候选码中的属性称为非主属性（Non-Prime Attribute）或非码属性（Non-key Attribute）。 关系的类别 # 1. 基本关系（基本表或基表） # 定义：实际存在的表，是实际存储数据的逻辑表示。 例子： 学生表（Students）：\n学号 姓名 年龄 性别 系名 202001 张三 20 男 计算机科学 202002 李四 21 女 数学 202003 王五 22 男 物理 课程表（Courses）：\n课程号 课程名 学分 C 001 数据库 3 C 002 高等数学 4 C 003 英语 2 2. 查询表 # 定义：查询结果对应的表。 例子： 查询“计算机科学系的学生”：\n学号 姓名 年龄 性别 系名 202001 张三 20 男 计算机科学 查询“学分大于 3 的课程”：\n课程号 课程名 学分 C 002 高等数学 4 3. 视图表 # 定义：由基本表或其他视图表导出的表，是虚表，不对应实际存储的数据。 例子： 创建一个视图“计算机科学系学生选课情况”：\nCREATE VIEW CS_Students_Courses AS SELECT Students.学号, Students.姓名, Courses.课程名 FROM Students, Courses WHERE Students.系名 = \u0026#39;计算机科学\u0026#39;; 查询视图： 学号 姓名 课程名 202001 张三 数据库 基本关系的性质 # 1. 列是同质的（Homogeneous） # 每一列中的分量（即单元格中的值）是同一类型的数据，来自同一个域。 例子：在“学生表”中，“年龄”列的所有值都是整数类型，来自“年龄”这一数据域。 2. 不同的列可出自同一个域 # 虽然每列的数据类型相同，但它们代表不同的属性。 例子：在“学生表”中，“年龄”列和“学分”列都来自整数域，但分别代表学生的年龄和课程学分。 3. 每一列称为一个属性 # 属性是关系模型中列的术语，代表某种特征或数据项。 例子：在“学生表”中，“姓名”、“年龄”、“性别”等都是属性。 4. 不同的属性要给予不同的属性名 # 不能有两个列都叫“姓名”，必须分别命名为“中文姓名”和“英文姓名”（if needed）。 5. 行、列的顺序无所谓 # 将“学生表”中的“姓名”列和“年龄”列对调，表的内容和含义不变。 将“学生表”中的第一行和第二行对调，表的内容和含义不变。 6. 任意两个元组的候选码不能相同 # 在“学生表”中，“学号”是候选码，每个学生的学号必须唯一。 7. 分量必须取原子值 # 每个分量（单元格中的值）必须是不可再分的最小数据单位（例如一个整数或字符串）。 例子：在“学生表”中，“姓名”列的值必须是单个名字，不能是一个名字列表。 关系模式 # 1. 定义 # 关系模式是“型”，关系是“值”。关系模式是对关系的描述。 内容包括： 元组集合的结构 属性构成 属性来自的域 属性与域之间的映射关系 完整性约束条件 2. 关系模式的形式化表示 # 关系模式可以形式化地表示为：\\(R(U, D, DOM, F)\\)\n\\(R\\)：关系名 \\(U\\)：组成该关系的属性名集合 \\(D\\)：\\(U\\) 中属性所来自的域 \\(DOM\\)：属性向域的映射集合 \\(F\\)：属性间数据的依赖关系集合 简化表示： 关系模式通常可以简记为 \\(R(U)\\) 或 \\(R(A_1, A_2, \\dots, A_n)\\)。 \\(R\\)：关系名。 \\(A_1, A_2, \\dots, A_n\\)：属性名。 域名及属性向域的映射通常直接说明为属性的类型和长度。 3. 关系模式与关系的区别 # 关系模式：对关系的描述，是静态的、稳定的。 关系：关系模式在某一时刻的状态或内容，是动态的、随时间不断变化的。 说明： 关系模式和关系在日常讨论中常笼统称为“关系”，需通过上下文加以区别。 关系数据库 # 定义：在一个给定的应用领域中，所有关系的集合构成一个关系数据库。 关系数据库的“型”与“值” 型：关系数据库模式，是对关系数据库的描述。 值：关系模式在某一时刻对应的关系的集合，通常称为关系数据库。 关系的完整性 # 关系间的引用 # 定义：在关系模型中，实体及实体间的联系都用关系描述，自然存在关系间的引用。 例子： 学生与专业： 学生（学号，姓名，性别，专业号，年龄） 专业（专业号，专业名） 学生关系引用了专业关系的主码“专业号”。 学生、课程与选修： 学生（学号，姓名，性别，专业号，年龄） 课程（课程号，课程名，学分） 选修（学号，课程号，成绩） 选修关系引用了学生关系的主码“学号”和课程关系的主码“课程号”。 学生内部的领导联系： 学生（学号，姓名，性别，专业号，年龄，班长【指的是这个学生所在班级的班长】） 学生关系引用自身的主码“学号”来表示班长关系。 外码 # 定义 # 设 \\(F\\) 是基本关系 \\(R\\) 的一个或一组属性，但不是关系 \\(R\\) 的码。如果 \\(F\\) 与基本关系 \\(S\\) 的主码 \\(K_S\\) 相对应，则称 \\(F\\) 是 \\(R\\) 的外码（Foreign Key）, 在这种情况下： 基本关系 \\(R\\) 被称作参照关系（Referencing Relation） 基本关系 \\(S\\) 被称作被参照关系（Referenced Relation）或目标关系（Target Relation）：。 说明： 关系 \\(R\\) 和 \\(S\\) 不一定是不同的关系。 目标关系 \\(S\\) 的主码 \\(K_S\\) 和参照关系的外码 \\(F\\) 必须定义在同一个（或一组）域上。 外码并不一定要与相应的主码同名。当外码与相应的主码属于不同关系时，通常取相同的名字以便于识别。 例子 # 学生与专业：\n学生关系：学生（学号，姓名，性别，专业号，年龄）\n其中，“专业号”是学生关系的外码。 专业关系：专业（专业号，专业名）\n其中，“专业号”是专业关系的主码。 专业关系是被参照关系，学生关系是参照关系。 选修关系：\n选修关系：选修（学号，课程号，成绩）\n其中，“学号”、“课程号”（之一，不是合起来）是选修关系的外码。 学生关系：学生（学号，姓名，性别，专业号，年龄）\n其中，“学号”是学生关系的主码。 课程关系：课程（课程号，课程名，学分）\n其中，“课程号”是课程关系的主码。 学生关系和课程关系是被参照关系，选修关系是参照关系。 学生内部的领导联系：\n学生关系：学生（学号，姓名，性别，专业号，年龄，班长）\n其中，“班长”是外码，引用了学生关系自身的主码“学号”。 学生关系既是参照关系，也是被参照关系。 关系的三类完整性约束 # 1. 实体完整性 Entity Integrity # 若属性 A 是基本关系 R 的主属性，则属性 A 不能取空值（表示“不知道”、“不存在”或“无意义”的值）。\n例子： 关系模式：选修（学号，课程号，成绩） 主码为“学号、课程号”，这两个属性均不能取空值 实体完整性规则是针对基本关系而言的。一个基本表通常对应现实世界的一个实体集。 现实世界中的实体是可区分的，即它们具有某种唯一性标识。 关系模型中以主码作为唯一性标识。 主码中的属性即主属性不能取空值。 主属性取空值，就说明存在某个不可标识的实体，即存在不可区分的实体，这与第 2 点相矛盾，因此这个规则称为实体完整性。 2. 参照完整性 # 若属性（或属性组）\\(F\\) 是基本关系 \\(R\\) 的外码，它与基本关系 S 的主码 \\(K_S\\) 相对应（基本关系 \\(R\\) 和 \\(S\\) 不一定是不同的关系），则对于 \\(R\\) 中每个元组在 \\(F\\) 上的值必须为下面两种情况之一 取空值（\\(F\\) 的每个属性值均为空值），代表 \\(R\\) 中的这个条目目前还不需要这个属性 等于 \\(S\\) 中某个元组的主码值，代表这个条目的属性必须要是有意义的（在 \\(S\\) 中存在） 当然如果 \\(F\\) 也是 \\(R\\) 的主码，那就不能取空值了，只能是第二种情况。\n用户定义的完整性 # 针对某一具体关系数据库的约束条件，反映某一具体应用所涉及的数据必须满足的语义要求。 关系模型应提供定义和检验这类完整性的机制，以便用统一的系统的方法处理它们，而不需由应用程序承担这一功能。 示例：课程（课程号，课程名，学分）\n“课程号”属性必须取唯一值。 非主属性“课程名”也不能取空值。 “学分”属性只能取值 \\({1, 2, 3, 4}\\)。 关系操作与关系代数 # 关系代数 # operand 是关系，计算结果也是关系 关系是集合，所以关系代数是集合的操作 operand有两类 集合运算符：只从行的角度进行，行很行操作产生新的行 专门的关系运算符：不仅涉及行，还涉及列 运算必须要有意义。\n使用的记号 # 规定只使用关系模式的结构 中的两样东西：关系名 和 属性名元组，也就是 $$ R(A_1, A_2, \\ldots, A_n) $$ 这个关系模式中：\n关系： \\(R\\) 表示一个关系实例。\n元组： \\(t \\in R\\) 表示 t 是 R 的一个元组\n分量：\\(t[A_i]\\) 表示元组 t 中属于属性 \\(A_i\\) 的一个分量\n属性列/属性组：设 \\(A={A_{i1}, A_{i2}, \\ldots, A_{ik}}\\), 其中的每一个元素都是 R 的属性，则 \\(A\\) 是属性列或属性组， \\(\\overline{A}\\) 表示所有属性去掉 A 后的剩余属性组\n连接：\n\\(t_r \\in R\\)，\\(t_s \\in S\\)，\\(\\overset{\\frown}{t_r t_s}\\) 称为元组的连接。 \\(\\overset{\\frown}{t_r t_s}\\) 是一个 n + m 列的元组，前 n 个分量为 R 中的一个 n 元组，后 m 个分量为 S 中的一个 m 元组。 象集： 给定一个关系 R（X，Z），X 和 Z 为属性组。\n当 \\(t[X] = x\\) 时，x 在 R 中的象集（Images Set）为： \\(Z_x = {t[Z] \\mid t \\in R, t[X] = x}\\) 它表示 R 中属性组 X 上值为 x 的诸元组在 Z 上分量的集合。 关系操作 # 1. 并 # \\(R \\cup S\\)\n两个关系目数必须同 每目属性相同，对应的属性应取自同一个域 仍为 n 目关系，由属于 R或属于 S 的元组组成 2. 差 # 和 并 一样，目数、属性有要求，不然运算没有意义 仍为 n 目关系，由属于 R 而不属于 S 的所有元组组成 3. 交 Intersection # 和前面一样，\u0026hellip; 仍为 n 目关系，由既属于 R 又属于 S 的元组组成 4. 笛卡尔积 # 严格地讲应该是广义的 (Extended) 笛卡尔积\n5. 选择 # 在关系 R 中选择满足给定条件的诸元组： $$ \\sigma_F(R) = {t \\mid t \\in R \\land F(t) = \\text{true}} $$\nF：选择条件，是一个逻辑表达式，取值为“真”或“假”。\n基本形式为：\\(X_1 \\theta Y_1\\)，其中：\n\\(\\theta\\) 表示比较运算符，可以是 \\(\u0026gt;\\)，\\(\\geq\\)，\\(\u0026lt;\\)，\\(\\leq\\)，\\(=\\) 或 \\(\\neq\\)。 在基本的选择条件上可以进一步进行逻辑运算（与、或、非）。\n选择运算是从关系 R 中选取使逻辑表达式 F 为真的元组，是从行的角度进行的运算. 6. 投影 # 从关系 R 中选择若干属性列 组成新的关系： $$ \\pi_A(R) = { t[A] \\mid t \\in R } $$ A：R 中的属性列。 投影操作主要是从列的角度进行运算。 投影之后不仅取消了原关系中的某些列，而且还可能取消某些元组（避免重复行）。 7. 连接 # 连接（Join）也称为 θ连接。\n连接运算的含义 # 从两个关系的笛卡尔积中选取属性间满足一定条件的元组： $$ R \\bowtie_{AθB} S = { \\overset{\\frown}{t_r t_s} \\mid t_r \\in R \\land t_s \\in S \\land t_r[A] \\theta t_s[B] } $$\nA 和 B：分别为 R 和 S 上度数相等且可比的属性组。 θ：比较运算符。 连接运算从 R 和 S 的广义笛卡尔积 \\(R \\times S\\) 中选取 R 关系在 A 属性组上的值与 S 关系在 B 属性组上的值满足比较关系 \\(theta\\) 的元组。\n等值连接（Equijoin） # 当 θ 为“=”的连接运算称为等值连接。从关系 R 与 S 的广义笛卡尔积中选取 A、B 属性值相等的那些元组，即： $$ R \\bowtie S = { \\overset{\\frown}{t_r t_s} \\mid t_r \\in R \\land t_s \\in S \\land t_r[A] = t_s[B] } $$\n自然连接（Natural Join） # 一种特殊的等值连接。\n条件：\n两个关系中进行比较的分量必须是相同的属性组。 在结果中把重复的属性列去掉。 自然连接的含义：\nR 和 S 具有相同的属性组 B： $$ R \\bowtie S = { t_r \\overset{\\frown}{t_s}[U-B] \\mid t_r \\in R \\land t_s \\in S \\land t_r[B] = t_s[B] } $$ 一般的连接操作从行的角度进行运算。 自然连接需要取消重复列，因此是同时从行和列的角度进行运算。\n外连接 # 悬浮元组（Dangling tuple） # 在两个关系 R 和 S 进行自然连接时，关系 R 中某些元组可能在 S 中不存在公共属性上值相等的元组，从而导致这些元组在操作时被舍弃。这些被舍弃的元组称为悬浮元组。 如上面例子中的 (a2, b4, 12)\n外连接（Outer Join） # 如果在结果关系中保留悬浮元组，并在其他属性上填充空值（Null），这种操作外连接。\n左外连接 (LEFT OUTER JOIN 或 LEFT JOIN)\n只保留左边关系 R 中的悬浮元组。 右外连接 (RIGHT OUTER JOIN 或 RIGHT JOIN)\n只保留右边关系 S 中的悬浮元组。 8. 除运算（Division） # 给定关系 \\(R (X, Y)\\) 和 \\(S (Y, Z)\\)，其中 X、Y、Z 为属性组。\nR 中的 Y 与 S 中的 Y 可以有不同的属性名，但必须出自相同的域集。\nR 与 S 的除运算得到一个新的关系 \\(P (X)\\)，P 是 R 中满足下列条件的元组在 X 属性列上的投影：\n元组在 X 上的分量值 x 的象集 \\(Y_x\\) 包含 S 在 Y 上投影的集合，记作： $$ R \\div S = { t_r[X] \\mid t_r \\in R \\land \\pi_Y(S) \\subseteq Y_x } $$ 其中，\\(Y_x\\) 是 x 在 R 中的象集，且 \\(x = t_r[X]\\)。 ","date":"2025 May 3","externalUrl":null,"permalink":"/posts/database-2/","section":"Posts","summary":"数据库笔记","title":"第2章：关系数据库","type":"posts"},{"content":" 数据的管理模式 # 数据的管理模式并没有绝对的优越性，只是适用于特定的情境。\n从下面几点考察：\n数据的管理者是谁？ 数据面向的对象是？ 数据的共享程度？ 数据的独立性？ 数据的结构化？ 数据的控制能力？ 1. 人工管理 # 数据由写程序的程序员管理，面向应用程序； 共享性没有，冗余度很高； 独立性无，因为是 hard-code 进程序里的； 结构性无； 由程序自己控制数据。 2. 文件系统 # 数据由文件系统管理，优点是可以长期保存； 存在共享性：json、XML 文件可以将数据共享给多个程序，但存在问题：谁负责定义与管理这些数据？具体来说， 数据的结构和存储机制要被所有应用接受； 数据的安全性、完整性 数据的并发性：对数据操作的顺序会影响数据的最终形态 如何在动态的情况（数据在多用户操作、频繁更新和环境变化中不断变化的状态）下解决这些问题 3. 数据库系统 # 首先要了解什么是数据库系统。\n3.1 基本概念 # 数据库系统的具体运行：\n数据（Data, 描述事物的符号化记录）是数据库存储的基本对象。 种类：数字、文字、图形、图像、音频、视频、学生的档案记录等 语义：数据的含义。数据与其语义密不可分。 93 是数据，他的语义可能是某人的体重，也有可能是成绩 数据库（DB）是长期储存在计算机内、有组织的、可共享的大量数据的集合。其基本特征： 数据是按一定的数据模型进行组织描述储存的 可为各种用户进行共享 冗余度小，不需要重复 数据独立性较高 易扩展 数据库管理系统（DBMS）：“科学地组织和存储数据、高效地获取和维护数据” 位于用户和 OS 之间 基础软件，大型、复杂 其作用： 数据定义：DDL 数据组织、存储与管理 数据操纵：DML 据库的事务管理和运行管理 数据库的建立和维护功能 6…. 数据库系统：DBS 数据库 DBMS 应用程序 数据库管理员（DBA） 核心与基础：数据模型 3.2 特点 # 数据的结构化 最小存取单位是数据项 不仅内部结构化，整体也是结构化的，也就是说数据之间具有联系 数据用数据模型描述，无需应用程序定义 共享性高。数据共享的好处 减少数据冗余，节约存储空间 避免数据之间的不相容性与不一致性 使系统易于扩充 数据的独立性高。 物理独立性：指用户的应用程序与数据库中数据的物理存储是相互独立的。数据的物理存储改变时，应用程序不用进行改变。 逻辑独立性：指用户的应用程序与数据库的逻辑结构是相互独立的。数据的逻辑结构改变了，应用程序不用进行改变。 数据由数据管理系统统一管理和控制。也就是文件系统中提到的 数据安全性保护 数据完整性检查 并发控制 数据库恢复 数据模型 # 定义：是对现实世界数据特征的抽象，用以抽象、表示和处理现实世界中的数据和信息。 要求： 模拟的真实性 易理解性 便于在计算机上实现 分类： 概念模型：用于设计一个数据库，按用户的观点来对数据和信息建模 逻辑模型：用于 DBMS 的实现，按照计算机系统的观点 物理模型：对数据最底层的抽象，描述数据在系统内部的表示方式和存取方法 三个模型是渐进的关系，通过两步抽象演变 组成要素： 数据结构：系统的静态特性 数据操作：系统的动态特性 数据的完整性约束条件 完整性规则：给定的数据模型中数据及其联系所具有的制约和依存规则 概念模型 # 用于信息世界的建模，是现实世界到机器世界的一个中间层次。数据库设计人员和用户之间进行交流的语言。\n较强的语义表达能力 简单、清晰、易于用户理解 信息世界中的基本概念 # 回忆：实体、属性、码；实体型、实体集、联系。\nentity 实体： 客观存在并可相互区别的事物称为实体。可以是具体的人、事、物或抽象的概念。 Attribute 属性： 实体所具有的某一特性称为属性。一个实体可以由若干个属性来刻画。 Key 码：唯一标识实体的属性集 Entity Type 实体型：用实体名及其属性名集合来抽象和刻画同类实体称为实体型 Entity Set 实体集：同一类型实体的集合称为实体集 Relationship 联系： 现实世界中事物内部以及事物之间的联系 在信息世界中反映为 实体（型）内部的联系和实体（型）之间的联系。 实体内部的联系通常是指组成实体的各属性之间的联系 实体-联系方法（E-R 方法， E-R 模型） # 画法：\n例子：\n逻辑模型 # “多快好省”地转换信息世界到机器世界： “多”：支持多种数据结构和应用场景。 “快”：高效地完成转换，减少时间和资源消耗。 “好”：确保数据的准确性和完整性。 “省”：节省存储空间和计算资源。 中立的通用表达方式 定义：不依赖于具体应用，提供一种通用的、抽象的数据表达方式。 特点：通用性强，灵活性高，效率可能较低 例子： 关系数据库 JSON 格式：一种通用的数据交换格式，可以表示各种结构的数据（如数组、对象等），适用于多种编程语言和应用。 针对应用的高效表达方式 定义：根据具体应用需求，设计专门的数据结构，并在逻辑模型中高效支持。 特点：高效性，针对性强，扩展性差 例子： 面向对象编程（OOP）：为特定功能设计类。例如，设计一个“学生”类，包含属性（姓名、年龄、成绩）和方法（计算平均分、打印信息）。这种结构在管理学生信息时非常高效，但难以直接用于其他场景。 电商应用中的“订单”对象：包含订单号、购买商品、金额等属性，专门用于处理订单数据，效率高但仅适用于电商场景。 综合方案 定义：通用数据结构采用方案 1（中立表达），关键性数据结构采用方案 2（针对应用优化）。 分类 # 格式化模型\nHierarchical Model 层次模型：以树状结构组织数据，表示一对一或一对多的关系。 Network Model 网络模型：以网状结构组织数据，支持多对多的关系，但结构复杂。 非格式化模型\nRelational Model 关系模型：基于表格结构，通过行和列存储数据，支持复杂的查询操作。 对象模型 Object Oriented Data Model 面向对象数据模型：以对象和类为核心，支持继承和封装。 Object Relational Data Model 对象关系数据模型：结合对象模型和关系模型，支持复杂数据类型和关系操作。 关系模型 # 1. 二维表结构 # 数据逻辑结构是一张二维表，由行（元组）和列（属性）组成。\n学号 姓名 年龄 性别 系名 年级 2013004 王小明 19 女 社会学 2013 2013006 黄大鹏 20 男 商品学 2013 2013008 张文斌 18 女 法律 2013 2. 基本概念： # 关系Relation：一张表。 元组Tuple：表中的一行。 属性Attribute：表中的一列，有属性名。 主码Key：能唯一确定一个元组的属性组。 域Domain：属性的取值范围。 分量：元组中的一个属性值。 关系模式：对关系的描述，如“学生（学号，姓名，年龄，性别，系名，年级）”。 规范化：关系必须规范化，每个分量是不可分的数据项，不允许表中还有表。 3. 操作与完整性约束 # 数据操作：集合操作，操作对象和结果都是关系；存取路径对用户隐蔽，用户只需指出“干什么”。 完整性约束： 实体完整性：确保每个实体（元组）可以通过主键唯一标识。例如，学生表中“学号”作为主键，每个学号必须唯一。 参照完整性：确保表之间的关系通过外键正确关联。例如，学生表的“系名”字段必须与系表中的“系名”匹配。 用户定义的完整性：根据用户需求定义的约束规则。例如，规定学生年龄必须大于 16 岁。 4. PROS/CONS # ➕\n建立在严格数学基础上，概念单一。 实体和联系都用关系表示，检索结果也是关系。 存取路径对用户透明，数据独立性高，安全保密性好，简化开发工作。 ➖ 查询效率不如格式化数据模型。 需对用户查询请求进行优化，增加了开发 DBMS 的难度。 以下是关于 NoSQL 的笔记，适当扩充并整理为简洁的 Markdown 格式：\nNoSQL 数据库类型 # 基于 Key-Value 存储模型\n存储键值对，适合快速读写操作。例如，Redis 通过键值对存储用户会话信息。\n基于文档模型\n存储半结构化数据，通常以 JSON 或 BSON 格式。例如，MongoDB 存储用户资料文档，包含姓名、年龄、地址等字段。\n列族模型\n按列存储数据，适合大规模数据存储和分析。例如，Cassandra 用于存储时间序列数据，按列族组织数据。\n基于图模型\n用于存储和查询复杂关系数据。记为 G(V, E)，其中 V 为节点集合，每个节点具有若干属性；E 为边集合，边也可以具有属性。例如，Neo4j 用于社交网络分析，节点表示用户，边表示用户之间的关系。\n数据库系统的结构 # 三级模式结构 # 1. 模式（Schema） # 定义：数据库中全体数据的逻辑结构和特征的描述。 数据的逻辑结构（数据项的名字、类型、取值范围等） 数据之间的联系 数据有关的安全性、完整性要求 特点： 是数据的“型”描述，不涉及具体值，反映数据的结构及其联系。 是相对稳定的，独立于数据的物理存储细节和硬件环境。（内模式） 与具体的应用程序、开发工具及高级程序设计语言无关。（外模式） 示例：学生选课数据库模式包含学生记录、课程记录和学生选课记录。 2. 实例（Instance） # 定义：反映数据库某一时刻的状态，是模式的一个具体值。 特点： 同一个模式可以有多个实例。 实例随数据库中的数据更新而变动。 示例： 2012 年学生数据库实例：包含 2012 年所有学生记录、课程记录和选课记录。 2013 年学生数据库实例：包含 2013 年所有学生记录、课程记录和选课记录。 3. 外模式/子模式/用户模式（External Schema） # 定义：用户使用的局部数据的逻辑结构和特征的描述，是与某一应用有关的数据的逻辑表示。 特点： 介于模式与应用之间，通常是模式的子集。 一个模式可以有多个外模式，反映不同用户的需求和数据保密要求。 同一外模式可以被多个应用系统使用，但一个应用只能使用一个外模式。 用途：保证数据库安全性，用户只能访问对应的外模式中的数据。 4. 内模式（Internal Schema） # 定义：数据物理结构和存储方式的描述，是数据在数据库内部的表示方式。 内容： 记录的存储方式（如顺序存储、堆存储、hash 存储）。 索引的组织方式、数据是否压缩或加密。 数据存储记录结构的规定。 特点：一个数据库只有一个内模式。 5. 数据库的二级映像与数据独立性 # 三级模式是对数据的三个抽象级别，二级映象在数据库管理系统内部实现这三个抽象层次的联系和转换。\n外模式/模式映像：逻辑独立性 # 每一个外模式，数据库系统都有一个外模式/模式映象（通常包含在各自外模式的描述中），定义外模式与模式之间的对应关系。\n作用：保证数据逻辑独立性\n当模式改变时，数据库管理员对外模式/模式映象作相应改变，使外模式保持不变。 应用程序是依据数据的外模式编写的，应用程序不必修改，保证了数据与程序的逻辑独立性，简称数据的逻辑独立性。 模式/内模式映像：物理独立性 # 定义了数据全局逻辑结构与存储结构之间的对应关系。例如，说明逻辑记录和字段在数据库内部是如何表示的，包括存储方式、索引组织、数据压缩等。\n每个数据库只有一个模式/内模式映像。 映像定义通常包含在模式描述中。 作用：保证数据的物理独立性\n当数据库的存储结构发生变化（如更换存储设备或优化存储结构）时，数据库管理员只需修改模式/内模式映像，而无需改变模式本身。 应用程序依赖于模式，而不是具体的存储结构。因此，即使存储结构改变，应用程序仍然可以正常运行，这就是数据与程序的物理独立性。 希望这份笔记能帮助你更好地理解模式/内模式映像的作用和意义。\n6. 数据库的二级映像的作用 # 稳定性：保证外模式和应用程序的稳定性，除非应用需求本身发生变化，否则应用程序无需修改。 独立性：数据与程序之间的独立性，使得数据定义可以从应用程序中分离，简化应用程序的编制和维护。 数据库系统的组成 # 甲乙丙丁，开中药铺…\n软硬件平台 # 硬件 # 对硬件资源的要求:\n- 足够大的内存 - 足够大的磁盘或磁盘阵列等设备 - 较高的通道能力，提高数据传送率 软件 # DBMS: 数据库管理系统 支持数据库管理系统运行的操作系统 与数据库接口的高级语言及其编译系统 以数据库管理系统为核心的应用开发工具 为特定应用环境开发的数据库应用系统 数据库系统的组成 - 人员 # 数据库管理员（DBA） # 决定数据库中的信息内容和结构 决定数据库的存储结构和存取策略 定义数据的安全性要求和完整性约束条件 监控数据库的使用和运行 周期性转储数据库 数据文件 日志文件 系统故障恢复 介质故障恢复 监视审计文件 数据库的改进和重组 性能监控和调优 定期对数据库进行重组，以提高系统的性能 需求增加和改变时，数据库需要重构造 系统分析员 / 数据库设计人员 # 系统分析员 负责应用系统的需求分析和规范说明 与用户及数据库管理员结合，确定系统的硬软件配置 参与数据库系统的概要设计 数据库设计人员 参加用户需求调查和系统分析 确定数据库中的数据 设计数据库各级模式 应用程序员 / 最终用户 # 应用程序员 设计和编写应用系统的程序模块。 进行调试和安装。 最终用户（End User）。最终用户通过应用系统的用户接口使用数据库。 偶然用户 不经常访问数据库，但每次访问数据库时往往需要不同的数据库信息 企业或组织机构的高中级管理人员 简单用户 主要工作是查询和更新数据库 银行的职员、机票预定人员、旅馆总台服务员 复杂用户 工程师、科学家、经济学家、科技工作者等 直接使用数据库语言访问数据库，甚至能够基于数据库管理系统的应用程序接口编制自己的应用程序 ","date":"2025 May 3","externalUrl":null,"permalink":"/posts/database-1/","section":"Posts","summary":"数据库笔记","title":"第1章：绪论","type":"posts"},{"content":"","date":"2025 May 3","externalUrl":null,"permalink":"/series/%E7%AC%94%E8%AE%B0-%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/","section":"Series","summary":"","title":"笔记-编译原理","type":"series"},{"content":"","date":"2025 May 3","externalUrl":null,"permalink":"/tags/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/","section":"Tags","summary":"","title":"编译原理","type":"tags"},{"content":"\n\n","date":"2025 May 3","externalUrl":null,"permalink":"/posts/compiler-ch-4-2/","section":"Posts","summary":"编译原理笔记","title":"编译原理笔记-未命名","type":"posts"},{"content":" PART I: Context-Free Language # CFG: Context Free Grammar # CFG 定义为一个一个一个四元组：\\(G = (N, T, S, P)\\)\n\\(N\\): 非终结符 non-terminal 有限集 \\(T\\): 终结符 terminal 有限集。终结符和非终结符不重合。 \\(S\\): 作为起点的非终结符，\\(S \\in N\\) \\(P\\): production rules $$A \\to a$$ \\(A \\in N\\), 是非终结符；\\(a \\in (N \\cup T)^*\\), 是某些终结符和非终结符的连接（或者单个符） CFG 的 Derivation: \\(\\Rightarrow_G\\) # Intro # 推导 (deviation) 是 CFG 的运算法则，用来从几个 production rules 推导到更多的 CFL.\n推导方式： Assumption: \\(A \\to \\gamma\\) Deviation: \\(\\alpha A \\beta ~\\Rightarrow_G ~\\alpha \\gamma \\beta\\)（可以省略下标 G, 如果语境比较清晰） 跳步骤、连续推导的符号：\\(\\Rightarrow^*\\) 这就是“上下文无关”的体现：assumption 所包含的性质不随这个单元的前面连接的东西 (\\(\\alpha\\)) 或者后面连接的东西 (\\(\\beta\\)) 的出现与否而改变\nCFL: Context Free Language # $$ L(G) = {w \\in T^*:~S \\Rightarrow^*w} $$\nCFL语言中的词是非终结符的集合，并且都能根据 CFG 的文法推导出来。\nLeft-Most Deviation \\(\\Rightarrow_{lm}\\) # 最左推导\n每一步推导都只把左边的 non-terminal 换成 terminal\n最右推导 \\(\\Rightarrow_{rm}\\) 类似喵\nParse Trees / Syntax Trees 语法树 # 上文中，给定一个终结符串，用最左推导构成的语法树。\n推导其实是建立语法树的过程。 语法树可以通过根据 production rules，从某个非终结符开始，进行一定顺序的推导（如最左/最右推导）构成 树中每个叶都是终结符，每个节点都是非终结符。 Ambiguity # Ambiguity 描述了 CFG 的一种性质：如果 CFG 构成的 CGL 中的一个字符串可以有多个不同的语法树，那么这个 CFG 是有二义性的；如果 CFL 的所有字符串都有唯一树的与之对应，那这个 CFG 就没有二义性。 Inherent Ambiguity # 有些 CFL 只有 ambiguous 的语法，也就是说对于这些语言我们无法消除其二义性。 并没有一个明确的算法来判定一个语法是否有二义性！ 并没有一个公式化的算法来消除所有能消除二义性的 CFL 的二义性！ (try to) Eliminating Ambiguity # 有几个尝试消除其二义性的方法\n1. Priority\u0026amp;Associativity # 提高某些运算符的优先级，先推导它们。\n2. 重写文法 # 比如 if-else 的二义性\nUsing Ambiguous Grammar (生肉) # Given that we cannot always eliminate ambiguity, just use it! We will discuss how we use ambiguous grammar in the next Lecture when introducing specific parsing techniques All regular languages are context-free languages. # PART II: Push-Down Automata # Intro # 来，复习一下 CFL\n来，复习一下Reg Lang和DFA/NFA的等价性\nRegular language = DFA/NFA Context-free language = PDA = \\(NFA + Stack (z0)\\) AI: PDA（Pushdown Automata，下推自动机）是一种理论计算模型，它扩展了有限自动机（DFA/NFA）的能力，通过引入一个栈（stack）来存储和检索信息。这个名字中的“push-down”（下推）源于其核心操作：在处理输入符号时，PDA 可以将符号推入栈（push）或从栈中弹出符号（pop），从而实现对输入的动态记忆和回溯能力。这种栈结构使得 PDA 能够处理具有嵌套结构或递归性质的语言，例如括号匹配或嵌套的函数调用，而这些是有限自动机无法处理的。下推自动机是研究上下文无关语言（CFG）的重要工具，它在编译原理中用于语法分析阶段，帮助解析程序代码的结构，确保其符合语言的语法规则。\n形式化定义：七元组 # 一个 NPDA/PDA 可以定义为以下形式\n$$ P = (Q, \\Sigma, \\Gamma, \\delta, q_0, z_0, F) $$\n\\(Q\\) 状态的有限集 \\(\\Sigma\\) 输入字符串的字母表 \\(\\Gamma\\) 可以入栈出栈的字母表 \\(\\delta\\) trasition function \\(Q \\times ( \\Sigma \\cup {\\epsilon} )\\times \\Gamma \\to 2^{Q \\times\\Gamma^*}\\) 左边：输入的字符和入栈的字符； 右边：到达的状态和目前在栈内的字符 (的连接)。Non-destiministic, 所以是幂集。 \\(q_0\\) 初始状态 \\(z_0\\) 栈内的初始字符 (stack start symbol) \\(F\\) final state 的集合，\\(F \\subseteq Q\\) Instantaneous Description # Instantaneous Description 是对 PDA 在某个状态的描述： $$ (q, w, \\gamma) $$\n\\(q\\): 当前状态 \\(w\\): 剩余没有进入状态机的输入 \\(\\gamma\\): 栈中剩下的内容 针对一个转换函数： $$(q, \\alpha) \\in \\delta(p, a, X)$$\n\\(p\\) 是之前的状态，\\(q\\) 是转换函数之后的状态 \\(X\\) 是要出栈的元素, \\(\\alpha\\) 是入栈的函数 \\(a\\) 是下一步的输入 我们有： $$ (p, aw, X\\beta) \\vdash_M(q, w, \\alpha\\beta) $$\nLanguage of PDA # PDA 既有入栈出栈，又有状态转移，因此有两种角度来定义 language, 并且可以证明二者其实等价。\nAcceptance by final states # 一个 string 能被 PDA 接受，如果\n所有的输入都被消耗 最终可以停留在一个 final state PDA 定义的语言自然是这些 stirng 的集合： $$ L(M) = {w \\in \\Sigma^: (q_0, w, z_0) \\vdash^_M (q_f, \\epsilon, u),~~ q_f \\in F, ~u \\in \\Gamma^*} $$ Acceptance by empty stack # 一个 string 能被 PDA 接受，如果\n所有的输入都被消耗 最终栈是空的 PDA 定义的语言自然是这些 stirng 的集合： $$ L(M) = {w \\in \\Sigma^: (q_0, w, z_0) \\vdash^_M (\\textcolor{red}{q}, \\epsilon, \\textcolor{red}{\\epsilon}),~~ \\textcolor{red}{q \\in Q}} $$ 等价？ # 如果一个语言可以通过某种 PDA 通过最终状态接受，那么也存在另一个 PDA 可以通过空栈接受相同的语言，反之亦然。\nPART III: CFG = PDA # 1. \\(CFG \\subseteq PDA\\) # 如何从 CFG 构造一个 PDA?\n对于个 CFG 四元组，我们可以构造一个等价的 PDA 七元组；令这个 PDA： $$ ({q}, T, T \\cup N, \\delta, q, S, \\varnothing) $$ 解析：\n只有一个状态，并且没有 final state. 也就是说这个 PDA 是 Acceptance by empty stack 的； 输入都是终结符，栈中的既可以是终结符也可以是非终结符； 初始状态时栈中只有一个作为起点的非终结符。 CFG 的规则如何向 PDA 的规则转化？\n对一个目标是空栈的 PDA, 状态不要紧，我们只关注 PDA 栈的变化：从栈顶开始 peek,\n如果栈中遇到一个非终结符 \\(A\\)，就把他 pop 出来，再入栈 CFG 中的 production rules 规定的推导 \\(A \\to \\gamma\\) 中的 \\(\\gamma\\): $$ \\delta(q, \\epsilon, A) = {(q, \\beta): A \\to \\beta \\in P} $$ 如果遇到一个终结符 \\(a\\)，就直接把他读取并弹出: $$ \\delta(q, a, a)= {(q, \\epsilon)} $$ 2. \\(PDA \\subseteq CFG\\) # 如何从一个（可能有点特殊的）PDA 构造 CFG?\n我们还是只讨论 Acceptance by empty stack 的 PDA, 为了方便我们忽略最终状态。对任何一个 PDA, 写成 \\((Q, \\Sigma, \\Gamma, \\delta, q_0, z_0, \\varnothing)\\), 我们找到一个 CFG 写作 $$ CFG(N, \\Sigma, P, S),~~~ N={S} \\cup {N_{p X q}:p, q \\in Q, X \\in \\Gamma} $$ 解析：\n定义非终结符集合：非终结符不仅包括起点的 non-terminal, 还包含 PDA 中任意一个路径，即把这个路径连同起点终点构造成一个包含了其特征的非终结符，叫做 \\(N_{pXq}\\), 代表从 p 状态转移到 q 状态，弹出 \\(X\\). 定义 production rules： 对于 PDA 任意一个状态 \\(q\\)，存在 rule: 初始的非终结符 \\(\\to\\) 从 \\(q_0\\) 到 \\(q\\)、弹出 \\(z_0\\) 剩下空栈的路径 $$ \\forall p \\in Q: S \\to N_{q_0 z_0 p} \\in P $$ 对于一个消耗输入 \\(a\\), 弹出 \\(X\\) 不压入任何字符的路径，存在 rule: $$ (q, \\epsilon) \\in \\delta(p, a, X) \\Rightarrow N_{pXq}\\to a \\in P $$ 对于一个消耗 \\(a\\), 弹出 \\(X\\) 并压入 \\(X_1X_2 \\ldots X_k\\) 的路径，存在 rule: $$ (q, X_1X_2\\ldots X_k) \\in \\delta(p,a,X) \\Rightarrow N_{pXp_k} \\to aN_{qX_1p_1}N_{p_1X_2p_2}\\ldots N_{p_{k-1}X_kp_k} \\in P $$ 例子：\nDPDA: Deterministic PDA # 在任何时刻，对于给定的输入符号或栈顶符号（这俩任意一个一样都不行），最多只有一个转移动作。\nCFL 一定有 PDA, 但是不一定有 DPDA. DPDA 的语言是没有二义性的！ PART IV: Properties of CFL # CLosure Properties # 给定两个 CFL \\(L_1\\) 和 \\(L_2\\)（对应的 CFG 起始非终结符分别是 \\(S_1\\) \\(S_2\\)）, 以下的语言也是 CFL：\n\\(L_1 \\cup L_2\\) \\(L_1L_2\\) \\(L^*_1\\) \\(L_1^R\\) Intersection of CFL # \\(L_1 \\cap L_2\\) 证明：取 \\(L_1={a^nb^nc^m},L_2={a^nb^mc^m}\\)，则 \\(L_1 \\cap L_2 = {a^nb^nc^n}\\), 这不显然不是 CFL? \\(\\overline{L_1}\\) 证明：\\(L_1 \\cap L_2 = \\overline{\\overline{L_1} \\cup \\overline{L_2}}\\) 如果非一定是 CFL, 那前面的交就一定是了。 \\(L_1-L_2\\) 证明：\\(\\overline{L_1} = \\Sigma^* - L_1\\) 但是一个 CFL 和一个 RL 的交是 CFL: 构建一个模拟 CFL 的 NPDA、一个模拟 RL 的 DFA, 把他们交起来\nApplication of the Properties # 为什么 \\(a^nb^n\\) 是 CFL? 因为能把他构造成一个很基础的 PDA.\nDecidable Properties # CFG（上下文无关文法）的可判定性质（Decidable Properties）是指可以通过算法来确定其结果的性质。\n1. 给定一个 CFG, CFL 是否为空？ # 检查起始非终结符是否没有被使用，或者无效使用 \\(e.g.~S\\to S\\)\n2. 给定一个 CFG, CFL 是否无限？ # 算法：\n移除无用的非终结符：\n无用的非终结符是指那些既不能推导出终结符字符串，也不能出现在任何可推导出终结符字符串的产生式中的非终结符。通过移除这些非终结符，可以简化文法，同时不影响其生成的语言。\n移除单元产生式和空产生式：\n单元产生式是指形如 \\(A \\rightarrow B\\) 的产生式，其中 \\(A\\) 和 \\(B\\) 都是单个非终结符；空产生式是指形如 \\(A \\rightarrow \\epsilon\\) 的产生式。移除这些产生式可以进一步简化文法，同时便于后续分析。\n构建剩余非终结符的依赖图：\n依赖图是一个有向图，其中每个节点代表一个非终结符，边 \\(A \\rightarrow B\\) 表示在某个产生式中，非终结符 \\(A\\) 可以直接或间接推导出非终结符 \\(B\\)。通过构建依赖图，可以直观地表示非终结符之间的推导关系。\n检查依赖图中是否存在环：\n如果依赖图中存在环，说明存在至少一个非终结符可以通过自身或一系列非终结符的推导最终回到自身。这种循环结构表明文法可以无限地生成字符串，因此生成的语言是无限的。如果没有环，则生成的语言是有限的。\n通过上述步骤，可以判断一个 CFG 生成的语言是否是无限的。\n3. 给定一个 CFG, 某个字符串是否属于其 CFL? # 算法 1：构造 NPDA, 看看 NPDA 能否接受这个 String 算法 2：the CYK algorithm (O (n3)) Undecidable Properties # CFG 是否有二义性 CFG 是否有不可避免的二义性 两个 CFG 的交是否为空 两个 CFG 是否等价 某个 CFG 是否可以等价为 \\(\\Sigma^*\\) PART V: Pumping Lemma for CFL # Chomsky Normal Form # 一种 CFG 的标准形式。如果 CFG 的所有 production rule 都是如下形式：\n\\(A \\to BC\\) \\(A \\to a\\) \\(S\\to\\epsilon\\) 其中 \\(a\\) 是终结符，\\(ABC\\) 是非终结符，\\(S\\) 是起始非终结符 那么这个 CFG 就是 CNF. 语法树是一个二叉树。 # 上下文无关语言的泵引理 # 定义： 泵引理可以用于证明一个语言不是上下文无关语言（CFL）。它指出，如果一个语言是上下文无关的，那么所有足够长的字符串都必须满足某些“可泵性”条件。\n泵引理的陈述： 设 \\(L\\) 是一个上下文无关语言（CFL）。则存在一个常数 \\(p\\)（称为泵长度），使得对于任何字符串 \\(s \\in L\\)，只要 \\(|s| \\geq p\\)，就可以将 \\(s\\) 分解为 \\(s = uvwxy\\)，满足以下条件：\n\\(|vx| \\geq 1\\)（即 \\(v\\) 和 \\(x\\) 至少有一个非空） \\(|vwx| \\leq p\\)（即 \\(vwx\\) 的长度不超过 \\(p\\)） 对于所有 \\(i \\geq 0\\)，字符串 \\(uv^iwx^iy\\) 仍然属于 \\(L\\)。 解释：\n条件 1：确保至少有一个部分可以被“泵”（即重复）。 条件 2：限制“可泵部分”的长度，使其在某个局部范围内。 条件 3：无论“泵”的次数多少，生成的字符串仍然属于语言 \\(L\\)。 应用： 泵引理主要用于证明某个语言不是上下文无关的。如果一个语言违反了泵引理的条件，则该语言不是上下文无关语言。\n示例： 假设 \\(L = {a^n b^n c^n \\mid n \\geq 1}\\)。假设 \\(L\\) 是上下文无关的，那么存在一个泵长度 \\(p\\)。选择字符串 \\(s = a^p b^p c^p\\)，根据泵引理，\\(s\\) 可以被分解为 \\(uvwxy\\)，满足上述条件。然而，无论怎样分解，都无法保证 \\(uv^iwx^iy\\) 仍然属于 \\(L\\)（因为 \\(a\\)、\\(b\\) 和 \\(c\\) 的数量必须严格相等）。因此，\\(L\\) 不是上下文无关语言。\n注意：\n泵引理只能用来证明一个语言不是上下文无关的，不能用来证明一个语言是上下文无关的。 对于某些语言，可能需要尝试多个字符串才能找到违反泵引理的反例。 ","date":"2025 May 3","externalUrl":null,"permalink":"/posts/compiler-ch-4-1/","section":"Posts","summary":"编译原理笔记","title":"Chapter 4-1 CFL \u0026 PDA","type":"posts"},{"content":" PART I: Regular Language # 定义 # 如果一个语言 \\(L\\) 能有一个 DFA/NFA \\(M\\) ，使得 \\(L = L(M)\\)，则 \\(L\\) 是 regular language\n封闭性 Closure Properties # 两个 regular language，他们的并、交、非、连接、逆、kleene star 也是 regular 的。 Regular language is closed under union, intersection, Reversal, complement, concatenation, and Kleene star\n\\(L_1 \\cup L2\\) # \\(L_1L_2\\) # \\(L_1^R\\) # \\(L_1^*\\) # \\(\\overline{L_1}\\) # \\(L_1 \\cap L_2\\) # 好像瞪不出来了？ 🤓👆事实上，可以用前面的形式拼接而成，因为德摩根定律： $$ L_1 \\cap L_2 = \\overline{\\overline{L_1} \\cup \\overline{L_2}} $$\nPART II: Regular Expression (regex) # Regex definition # Regex 被递归地定义，以下的称为 regex：\nPrimitive regex 空集（∅）：表示空语言，即不包含任何字符串 空字符串（ε）：表示只包含空字符串的语言 单个字符：a ∈ Σ，表示只包含字符 a 的语言 扩展法则：给定的两个 regex, 它们的： 并集（Union）：如果 R 和 S 是 regex，则 R | S 也是 regex 连接（Concatenation）：如果 R 和 S 是 regex，则 RS 也是 regex 闭包（Kleene Star）：如果 R 是 regex，则 \\(R^*\\) 也是 regex R 是 regex, (R) 也是 regex 例如： a*：表示所有由字符 a 组成的字符串，包括空字符串。 a|b：表示只包含字符 a 或字符 b 的字符串。 (ab)*：表示所有由 ab 重复零次或多次组成的字符串。 Language defined by regex # \\(L (\\varnothing) = \\varnothing;~ L (\\epsilon) = {\\epsilon};~ L (a) = {a}\\) 扩展： \\(L (r_1|r_2) = L (r_1) \\cup L(r_2)\\) \\(L (r_1r_2) = L (r_1) L(r_2)\\) \\(L (r_1^) = (L (r_1))^\\) \\(L ((r_1)) = L (r_1)\\) 判断正则表达式等价 # Two regex are equivalent if they represent the same language 也就是说分别话这两个 regex 代表的 language 对应的状态机，判断等价即可。\nLaws of regex # 和离散数学中的许多概念相似（虽然你离散数学没做笔记），regex 具有：\n交换性 commutativity \u0026amp; 结合性 associativity 元 Identity 和零化子 Annihilator 分配律 distributive 和自反 idempotent 封闭性 Closure Regex 与 regular language 等价 # 1. Regex-\u0026gt;reg lang # Any regex represents a regular language.\n回忆 regular language 的定义，发现上面的话可以等价成\n任何正则表达式 (regex) 都可以对应一个 NFA/DFA.\n转化方法 # Primitive regex 可以用 NFA/DFA 表示： Regex 的扩展法则也能用 NFA/DFA 表示，怎么证明？ 回忆我们之前是如何通过拼接构造新的自动机来证明 reg Lang 在并、连接、kleene star 下是封闭的。这分别对应 regex 的三个（其实有四个，只不过最后一个是废话）扩展法则。 总结 把目标 regex 用语言表示且化成最简形式； 把最小单元的 primitive regex 的状态机画出来; 根据语言的并/连接/star, 把这些基础的状态机拼接起来 例子 2. Reg Lang-\u0026gt;regex # Any regular language can be expressed by a regex.\n和前面的套路一样，可以理解成\n任何一个 DFA 都可以被一个 regex 表示。\n转化方法 # 把每个状态用距离小于等于一的状态表示 化简 PART III: Lexical Analysis # 词法分析究竟如何工作？\n为词素（如数字、变量等）编写正则表达式； 基于 regex, 构建 NFA-\u0026gt;化简成 DFA 如果一开始不是 DFA-\u0026gt;将 DFA 最简化 将源代码视作一个长长的输入字符串 将输入字符串与构建好的 DFA 匹配，细节上让多个 DFA 共同工作，需要的特性有 DFA 有不同的优先级，先匹配\u0026hellip; 再匹配\u0026hellip; 这样 贪婪匹配，总是匹配符合正则表达式的最长字符串 PART IV: Pumping Lemma # 泵引理。\n假设存在一个 regex, 对应的状态机称作 \\(M\\)，对应的语言称作 \\(L\\)。 如果一个字符串 \\(w \\in L\\), 并且 \\(w\\) 足够长——具体来说，如果 \\(w\\) 长到 \\(|w| \\geq m\\)，其中 m 是状态机的状态总数，那么 w 输入状态机所走过的路径中必定含有重复路径，也就是走过了不止一次的路径。\n这个重复的路径就是\u0026quot;泵\u0026quot;，容易知道可以在 \\(w\\) 的基础上构造字符串，字符串中这个“泵”可以重复无数次，重复后得到的字符串一定还是在这个正则表达式对应的语言中（因为还是可以被状态机 \\(M\\) 所接受）。\n严格定义 # 如果\n\\(L\\) 是一个无限的正则表达式，则 一定存在一个正整数 \\(m\\), 对任何 \\(w \\in L\\) 并且 \\(|w| \\geq m\\) 的字符串 \\(w\\)， 我们都能把 \\(w\\) 写成 $$w=xyz$$ 其中 \\(|xy| \\leq m\\) 且 \\(|y| \\geq 1\\), 使得 $$w_i=xy^iz \\in L$$ 其中 \\(i \\geq 1\\). 这个定义中 y 就是可以不同重复的泵，只要找到的特殊字符串足够长，就可以认为这个 y 存在。\n有什么用？ # 可以用该引理的逆否命题来证明一个字符串/语言并非 regular:\n对于任何一个正整数 \\(m\\), 如果存在 \\(w \\in L\\) 使得 \\(|w| \\geq m\\) 自行挑一组 \\(xyz\\)，使得 \\(w = xyz, y \\neq \\epsilon, |xy| \\leq m\\) 如果还能找到一个 k, 使得 \\(xy^kz \\notin L\\) 那么就能证明 \\(L\\) 并非正则！ 例证 # 例如，考虑语言 \\(L = {a^n b^n | n ≥ 0}\\)，即由相同数量的 \\(a\\) 和 \\(b\\) 组成的字符串。假设这个语言是正则的，那么根据泵引理，存在一个泵长度 \\(p\\)。选择一个字符串 \\(w = a^p b^p\\)，它显然属于 \\(L\\)。根据泵引理，\\(w\\) 可以分解为 \\(w = xyz\\)，其中 \\(|xy| ≤ p\\)，\\(|y| ≥ 1\\)。因为 \\(w\\) 的前 \\(p\\) 个字符都是 \\(a\\)，所以 \\(y\\) 必然只包含 \\(a\\)。假设 \\(y = a^k\\)，其中 \\(k ≥ 1\\)。\n现在，考虑字符串 \\(xy^2z = a^{(p+k)} b^p\\)。这个字符串显然不属于 \\(L\\)，因为它包含的 \\(a\\) 的数量多于 \\(b\\) 的数量；但是根据泵引理他又应该是属于 \\(L\\) 的。因此语言 \\(L\\) 不是正则的。\n","date":"2025 May 3","externalUrl":null,"permalink":"/posts/compiler-ch-3-2/","section":"Posts","summary":"编译原理笔记","title":"Chapter 3-2 Lexical Analysis","type":"posts"},{"content":" PART I: Math Preliminaries # String and apphabet # language: 一个字符串组成的集合：cat, dog, ... string: 字符 (letter) 序列，字符从 alphabet (如 \\(\\sum = {a, b, c, d, \u0026hellip;, z}\\)) 而来。\n对一个简单的 alphabet \\(\\sum = {a, b}\\)，\nStrings: a, b, aab, \u0026hellip;. Language：string 全集的任意子集；或者说 Kleene Star 的任意子集 String opeartion # 1. Concatenation # $$ w_1 = aabb $$ $$ w_2 = bbaa $$ $$ w_1w_2 = aabbbbaa $$\n2. Reverse # $$ w = abcd $$ $$ w^R=dcba $$\n3. Length # $$w = a_1a_2a_3a_4$$ $$|w| = 4$$\nEmpty String # \\(\\epsilon\\) \\(|\\epsilon| = 0\\) \\(\\epsilon aabb = aabb\\)，也就是说可以放在任何地方\nSub-string # Substring: 子串 Prefix and suffix: \\(w = uv\\), u 是 prefix, v 是 suffix, u/v 可以是 \\(\\epsilon\\)\nPower, Kleene Star, Plus # Power # \\(w^n\\) 是 n 个 w 拼接在一起 \\(w^0\\) 必是 \\(\\epsilon\\) Kleene Star # 对一个简单的 alphabet \\(\\sum = {a, b}\\) Kleene Star \\(\\sum^{\\ast}\\) 是所有用 alphabet 组成的 string 的集合，包括空集 Language 的新定义：Kleene star 的任意非空子集，包括 \\({ \\epsilon }\\)\nPlus # \\(\\sum^+\\) = \\(\\sum^{\\ast}\\) - \\({ \\epsilon }\\)\nOperation on Languages # 并，交，减 补 Complement: 等于 Kleene Star 减去自身 Reverse: Concatenation: 有点像 笛卡尔积 实例： Power Star-Closure Positive-Closure PART II: Deterministic Finite Automata # Intro # 有限状态机的输入是一个 String, 经过有限状态机后，输出\u0026quot;Accept\u0026quot;或\u0026quot;Reject\u0026quot;.\n最终停在 final state 就 accept, 否则 reject. 比如，对于输入 abb，这个状态机的运行： 可以看出每一步的走向都只有一种情况，所以叫 Deterministic. DFA 的表示 # 五元组表示 \\(Q\\): 有限数量的状态，如 \\(q_1, q_2, \\ldots\\) \\(\\sum\\): 有限集，元素是字符，是有限机的输入 \\(\\sigma\\) : 转换方程，可以列表格表示 \\(q\\): 当前状态 \\(a\\): 字母，下一次输入 \\(q\u0026rsquo;\\): 下一个状态 \\(q_0\\): 起始状态, 唯一 \\(F\\): final state 的集合。 转换方程有扩展版的，此时 \\(\\sum\\) 变成了其 Kleene Star, 也就是输入多个字符，one at a time\n用 DFA 定义语言 # 能够被某个状态机 \\(M = (Q, \\sum, \\theta, q_0, F)\\) 接受的 language （也就是说，language 的 string 作为输入进入 DFA 能停在 final state）被记作 $$ L(M) = {w \\in \\Sigma^* | \\sigma^*(q_0, w) \\subseteq F } $$\nDFA Minimization # 先把非 final state 放进一个集合，final state 放在一个集合 查看每个集合中的每一个状态接受某个输入后的下一个状态，如果这个集合接受相同的输入进入的下一个状态都在一个集合，就合法；否则不合法，要把不合法的状态放进新的集合。 重复这个操作，知道无法再细分。 这种算法的平均复杂度： $$ \\Omega(n \\log \\log n) $$\nDFA Bi-Simulation # 一种用于分析和比较两个 DFA 行为等价性的技术。Bi-Simulation 的核心思想是通过建立一种关系，使得两个 DFA 的状态在某种意义上“行为相似”，即一个 DFA 的行为可以模拟另一个 DFA 的行为，反之亦然。\n在 DFA 的上下文中，Bi-Simulation 关系通常用于证明两个 DFA 是否接受相同的语言, 即，\\(L (M_1) = L(M_2)\\)\n算法 # 等价条件 # 给一个输入字符串，让要进行比较的两个有限机共同运作，让 $$M_1 到达 finalstate$$ 和 $$M_2 到达 finalstate$$ 是等价条件，则认为二者等价。\n具体步骤 # 将两个DFA 的初始状态配成一个 state pair 让这个 pair 接受所有可能的输入，分别产生新的 state pair; 观察产生的 state pair, 如果满足上面提价的等价条件，则继续，否则肯定不等价； 将产生的新的（和之前不重复的）state pair 重复第二部，接受输入继续产生 state pair\u0026hellip;. 直到无法产生新的 state pair, 如果始终满足等价条件，则两个 DFA 确实等价。 概括地说，如果存在一个双模拟关系，使得两个 DFA 的初始状态相关联，并且这种关系能够扩展到所有可达状态，则这两个 DFA 被认为是等价的。\nPART III: Non-deterministic Finite Automata # Intro # 之前说过，输入确定，DFA 的每一步都是只有一种情况的，本节的状态机就有不止一种。\n如上例，aa只要有一条路径能走到 final state, 就可是说是被 accepted 了。 NFA 的表示 # \\(\\epsilon ～transition\\): 不消耗任何输入也能进行的状态转换。\n仍然用五元组表示，但区别：\n\\(\\Sigma \\cup {\\epsilon}\\): \\(\\epsilon\\) 也能作为状态转换的输入 \\(\\sigma:~Q\\times (\\Sigma \\cup {\\epsilon}) \\vdash 2^Q\\) 第二个参数的定义域多了 \\(\\epsilon\\) \\(2^Q\\) 就是 \\(P(Q)\\), 是 Q 的幂集，表示最后的状态不再是确定的一个元素，而是多个可能的状态组成的集合 \\(\\epsilon ~closure\\): \\(\\epsilon\\) -closure (q) returns all states q can reach via \\(\\epsilon\\)-transitions, including q itself\nNFA 转换方程的扩展形式 # $$ \\sigma:~Q\\times\\Sigma^*\\vdash2^Q $$\n\\(q\u0026rsquo;\\) 能被扩展形式的转换方程 \\(\\sigma^*(q, w)\\) 接受，当且仅当： \\(q\\) 经过 w 的输入到达q'' \\(q\u0026rsquo;\\) 是 \\(\\epsilon\\) -closure (q) 中的元素。 用 NFA 定义语言 # 能够被某个 NFA \\(M = (Q, \\sum \\cup {\\epsilon}, \\theta, q_0, F)\\) 接受的 language 记作 $$ L(M) = {w \\in \\Sigma^* | \\sigma^*(q_0, w) \\cap F \\neq \\varnothing} $$ 也就是说，只要最终能到的所有状态中包含最终状态，就能算作被 NFA 接受。\nDFA = NFA # DFA只是一个特殊形式的NFA NFA 可以用特定算法转换成 DFA，转换前后的 language 是等价的。 子集构造法：from NFA to DFA # DFA 的初始状态：DFA 的初始状态进行 \\(\\epsilon\\) 闭包计算后得到的状态集合作为 DFA 的初始状态。 从初始状态开始，对NFA的每个状态进行： 找出其对某个输入（say a）的所有转移后的状态； 对这些状态再进行闭包运算，得到的所有状态构成一个集合，这个集合就是 DFA 经过输入 a 后转移到的状态。 继续找其他的输入（当然不包括 \\(\\epsilon\\)）得到 DFA 的其他状态转移情况。 最后得到 DFA。 符号化说明： 🌰： 在子集构造法中，DFA的每个状态都是NFA状态的集合。因此，如果NFA有n个状态，那么DFA的状态数量最多可以是 \\(2^n\\) 个，因为n个状态的所有可能子集数量是 \\(2^n\\)。\n对于每一个n，都存在一些n-状态的NFA，其中从初始状态集合出发，可以到达所有可能的状态子集。这意味着在最坏情况下，转换后的DFA将恰好有\\(2^n\\)个状态。\n由于在最坏情况下DFA的状态数量是\\(2^n\\)，因此转换过程的时间复杂度是\\(Θ(2^n)\\)。这表示转换过程的时间随着NFA状态数量的增加而指数增长。\n当将NFA转换为DFA时，没有保证转换后的DFA会比NFA更小。实际上，由于DFA状态是NFA状态的集合，因此在最坏情况下，DFA的状态数量会远大于NFA。\n","date":"2025 May 3","externalUrl":null,"permalink":"/posts/compiler-ch-3-1/","section":"Posts","summary":"编译原理笔记：了解有限状态机","title":"Chapter 3-1 Finite Automata","type":"posts"},{"content":"","date":"2025 May 3","externalUrl":null,"permalink":"/tags/%E6%9C%89%E9%99%90%E7%8A%B6%E6%80%81%E6%9C%BA/","section":"Tags","summary":"","title":"有限状态机","type":"tags"},{"content":" Part I Compilers # 一、基本了解：Compiler, Interpreter 和 Linker # 什么是 Compiler？ # 编译器的作用就是将源语言转换为目标语言，以便计算机能够执行。 一些编译器（称作 transpiler）还尝试把源语言转换成另一种目标语言，比如热门的 C-\u0026gt;Rust 什么是 Interpreter? # 逐条读取源代码，并一条条的翻译成机器语言并执行。 不会生成独立的目标代码，每次执行都要从头翻译，这个意义上，效率比编译器低 一个特殊的变体：Java 什么是 Linker? # 将多个文件（Compilation units 说是）组合成一个文件——可执行文件或者库 编译与链接的流程： 其中， -O1 中的 -O 是编译优化选项； -l 是链接选项。 二、编译器的具体编译流程 # IR 指的是中间表示 (intermediate representation)\n前端：读取文件信息（词法语法语义）；将代码转化成 IR 中端：“从 IR 到 IR”, 是 machine-independent optimization 后端：也有machine-independent optimization，还有最终目标代码的生成 Front End # Lexical analysis # 词法分析\nFind lexemes according to patterns, and create tokens\n将文件中的字符（根据预订的 pattern）分割成一个个语素 Lexeme, 创造一个个 token\nLexeme: 人类理解的一个字符串 Pattern: 表征字符串的性质，通常是 regex. 如果没有 pattern 匹配到文件中的某个内容，就产生 Lexical Errors Token: 词法分析中的输出，源代码的基本单元： Token=\u0026lt;token-class, attribute\u0026gt; 如 INTEGER, 42, L_PAREN, ( Syntax Analysis # 语法分析\nCreate the (abstract) syntax tree (AST)\n创建语法树。\nSymbol table, symbol tree…\nSemantic Analysis # 语义分析\n主要任务是检查程序的语义是否正确，即使程序通过了语法分析，也不一定意味着它是有效的。例如： 检查变量是否已声明。 检查类型是否匹配。 检查操作符是否适用于操作数。 添加语义信息：语义分析会为抽象语法树（AST）的每个节点添加语义信息，这些信息通常包括： 类型信息：变量、表达式和函数的类型。 作用域信息：变量和函数的作用域。 符号表信息：符号表中存储的变量和函数的定义。 IR Generation # 根据 AST 生成 IR, 如三地址码\nMiddle End # 中端针对 IR, 提供了和机器无关的优化. IR 相对源码，提供了更易处理的标准形式；相对目标码，提供了其机器无关的上层抽象。（机器无关：和硬件处理和指令集差异无关，任何 ISA 通用）\nBack End # Translate IR to machine code (Meanwhile) Perform machine-dependent optimization\nInstruction Selection 不同格式风格的指令各有优劣。 Register Allocation 寄存器比内存快得多，但是个数有限，所以分配寄存器要有一定的优化策略，这不是乱搞的 Instruction Scheduling (指令调度) 目标机器通常提供支持指令级并行（Instruction-Level Parallelism, ILP）的硬件资源，如多个执行单元、超标量架构或多发射处理器。指令调度的目标是生成能够充分利用这些并行资源的机器代码，从而提高程序的执行效率。 Part || Tools # 看你的 PPT 去,,\nProgramming languages # 函数式编程（Functional Programming） # 定义\n函数式编程仅包含函数，不改变状态或数据。每个函数都是独立的，不依赖于外部状态。 也就是说，不存在全局变量了。 函数式编程的核心是通过组合和应用函数来解决问题。\n函数可以作为参数传递，也可以返回新的函数。\n以下是关于**逻辑编程（Logic Programming）**的笔记，结合了你提供的例子：\n逻辑编程（Logic Programming） # 1. 定义 # 逻辑编程是一种基于数学逻辑的编程范式，通过声明事实（Facts）和规则（Rules）来描述问题，而不是直接指定解决问题的步骤。\n2. 核心概念 # 事实（Facts）：表示已知的、不可改变的陈述。 规则（Rules）：表示基于事实推导出新结论的逻辑关系。 查询（Queries）：通过逻辑推理引擎验证或推导出新的事实。 3. 示例 # 以下是一个逻辑编程的简单示例，使用了事实、规则和查询：\n事实（Facts） # rainy(\u0026#34;Nanjing\u0026#34;). rainy(\u0026#34;Beijing\u0026#34;). cold(\u0026#34;Beijing\u0026#34;). 声明了两个城市（南京和北京）的天气情况。rainy(\u0026quot;Nanjing\u0026quot;) 表示南京是多雨的，rainy(\u0026quot;Beijing\u0026quot;) 和 cold(\u0026quot;Beijing\u0026quot;) 表示北京是多雨且寒冷的。\n规则（Rules） # snowy(C) :- rainy(C), cold(C). 规则表示如果一个城市既多雨又寒冷，那么它就是下雪的。snowy(C) 是结论，rainy(C) 和 cold(C) 是前提条件。\n查询（Queries） # ?- snowy(X). 查询所有满足 snowy 条件的城市。逻辑引擎会根据事实和规则进行推理，输出符合条件的城市。\n特点 # 逻辑编程是声明式的，程序员只需要声明事实和规则，而不需要指定具体的执行步骤。 逻辑引擎会自动进行推理，根据事实和规则推导出新的结论。 逻辑编程适合解决复杂的逻辑问题，如推理、规划和知识表示。 以下是关于**类型系统（Type Systems）**的笔记，严格按照要求格式化：\nType Systems 类型系统 # Static Typing / Dynamic Typing # 静态类型: 在编译时获取类型信息。 例如 Java 中， String str = \u0026ldquo;Hello\u0026rdquo;; // 被静态存储 str = 5; // 报错，因为str类型已经被staticcally(编译时)确定\n- 动态类型: 在运行时获取类型信息。 Python 中， ```python str = \u0026#34;Hello\u0026#34; # 此时是string str = 5 # 变成整型，不会报错 Strong Typing / Weak Typing # 强类型: 类型区分严格，不允许隐式类型转换。 Python 中， str = 5 + \u0026ldquo;hello\u0026rdquo; #报错，python其实是强类型\n注意 py 是动态类型，编写时不要显示标注类型，但*不是弱类型*！ - 弱类型: 类型区分较宽松，允许隐式类型转换。 Php: ```php $str = 5 + \u0026#34;hello\u0026#34; # string 在php中被隐式cast成0,所以结果是0 Scoping 作用域 # Static Scoping（静态作用域） # 根据程序的源代码结构来确定变量的作用域\n变量的作用域在编译时确定，与程序的结构（如函数嵌套）相关。 函数中引用的变量在定义时就绑定到其最近的外部作用域。 便于代码理解和优化，现代语言（如 C、Python、JavaScript 等）大多采用静态作用域。 Dynamic Scoping（动态作用域） # 根据程序的 运行时状态（调用栈） 来确定变量的作用域。\n变量的作用域在运行时确定，与函数调用顺序相关。 函数中引用的变量绑定到最近的调用环境中的变量。 更灵活，但难以理解和优化，主要用于某些脚本语言（如 Emacs Lisp）。 Function Invocation # Virtual Functions 虚函数 # 虚函数是在基类中声明的成员函数，可以被派生类重新定义 override。 虚函数允许实现多态（Polymorphism），即通过基类指针或引用调用函数时，会调用实际对象的版本。 虚函数必须是non-private、non-static且non-final。 在 Java 中，任何非私有、非静态且非 final 的方法都是虚函数，可以被 overridden. 示例代码 # 1. void add(List\u0026lt;Integer\u0026gt; list, Integer y) { 2. list.add(y); // 调用的是ArrayList.add()还是LinkedList.add()？ 3. } 在上述代码中，List 是一个接口，ArrayList 和 LinkedList 是其实现类。 调用 list.add(y) 时，实际调用的方法取决于 list 的运行时类型（即实际对象的类型），而不是其声明类型。这是虚函数（多态）的典型行为。 ","date":"2025 May 3","externalUrl":null,"permalink":"/posts/compiler-ch-1-and-2/","section":"Posts","summary":"编译原理笔记：了解编译器设计的大致流程，和构建编译器的相关工具","title":"Chapter 1\u00262 Intro to Compilers\u0026Tools","type":"posts"},{"content":"","date":"2025 May 3","externalUrl":null,"permalink":"/tags/%E6%A6%82%E8%BF%B0/","section":"Tags","summary":"","title":"概述","type":"tags"},{"content":"","date":"2025 April 29","externalUrl":null,"permalink":"/tags/free/","section":"Tags","summary":"","title":"Free","type":"tags"},{"content":"","date":"2025 April 29","externalUrl":null,"permalink":"/tags/server/","section":"Tags","summary":"","title":"Server","type":"tags"},{"content":"","date":"2025 April 29","externalUrl":null,"permalink":"/categories/techplay/","section":"Categories","summary":"","title":"TechPlay","type":"categories"},{"content":"","date":"2025 April 29","externalUrl":null,"permalink":"/tags/vps/","section":"Tags","summary":"","title":"Vps","type":"tags"},{"content":"","date":"2025 April 29","externalUrl":null,"permalink":"/tags/%E8%96%85%E7%BE%8A%E6%AF%9B/","section":"Tags","summary":"","title":"薅羊毛","type":"tags"},{"content":"","date":"2025 April 29","externalUrl":null,"permalink":"/tags/%E6%95%99%E7%A8%8B/","section":"Tags","summary":"","title":"教程","type":"tags"},{"content":"写下这些文字的时候，本站正处于⭐寄掉⭐的状态——服务器使用校园网， 而用curl认证的校园网时不时会断开（据室友经验,是不小心连上了无线网导致的）；ssh又发电了，可能是因为我的环境从宿舍变成了教室， 主机的ip地址从10.xx变成172.26.xxx，这就导致我无法连接还在宿舍的服务器来配置网络。1为了让网站不那么鸡肋，同时满足折腾的精神需求， 我决定在这次近代史课上尝试配置一个云主机，并记录过程与遇到的问题。\n开始配置之前 # 关于VPS # VPS（Virtual Private Server，虚拟专用服务器）是使用虚拟化技术，在一台物理服务器上划分出的多个独立“虚拟服务器”。 每个 VPS 都拥有自己的操作系统、存储空间、CPU、内存和网络接口，就像一个小型的云服务器。\nVPS 通常运行在大型云平台（如 微软的 Azure、亚马逊的AWS、阿里云）之上，这些平台拥有大量的公网 IP 资源。云平台为了让用户能远程连接 VPS（如 SSH、RDP），通常会： 为每台 VPS 自动或手动分配一个 公网 IPv4 地址，并且 公网 IP 直接绑定到该 VPS 的网络接口，或通过 NAT 映射，也就变相地获得了一个公网ip地址。\n选择提供商 # 作为新手并不要求VPS服务的质量和硬件配置有多好，所以只会寻找免费服务，参考了这篇博客文章。 总结下来，只有甲骨文(Oracle)可以永久白嫖服务器，但是注册非常麻烦，并且需要一个支持国际货币的 visa 卡，实在懒得办了。 而 Azure 服务会为学生提供每年 100 美金的免费额度，只需要一个 edu 邮箱就可以申请，所以我选择了Azure.\n配置 Azure # 主要参考这篇文章。这篇文章已经非常详细了，配置过程中没有遇到任何问题（除了云主机涨价），至福！\nOMG It\u0026rsquo;s CSDN💩!\n推荐搭配净化 CSDN 脚本使用；希望你点开链接之前，这篇文章不会成为 💩VIP💩 专属。\n下一步……? # 没想到获取一个ip地址这么容易，也没想到服务器连不上的原因这么抽象1。总之，既然两个主机都挺稳定的， 可以考虑让这两个服务器一起负责为这个网站服务，做负载均衡。\nWell actually🤓👆, 以上整个推论都是错误的。在写完这篇后回寝室发现，内外网都断了——但只是因为我中午不小心碰了一下主机导致网线松动， 没有连上。\u0026#160;\u0026#x21a9;\u0026#xfe0e;\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n","date":"2025 April 29","externalUrl":null,"permalink":"/posts/configuring-vps/","section":"Posts","summary":"记录了自己决定搞一个免费的云主机玩玩的全过程，以及一些科普和吐槽。","title":"我是学生，送我——使用Microsoft Azure配置云主机","type":"posts"},{"content":"","date":"2025 April 29","externalUrl":null,"permalink":"/tags/%E4%BA%91%E4%B8%BB%E6%9C%BA/","section":"Tags","summary":"","title":"云主机","type":"tags"},{"content":"","date":"2025 April 29","externalUrl":null,"permalink":"/tags/%E6%8A%98%E8%85%BE/","section":"Tags","summary":"","title":"折腾","type":"tags"},{"content":"在这个各种自动化工具都发展的十分健全的年代，建立静态托管的个人网站已经不再是一种非常geek的事情了，这甚至不比重装windows系统困难多少。建站的花费也是微乎其微：如果不执着于网站的域名，也不介意网站时不时无法访问，你甚至不需要花一分钱来达成这个目的；你需要的只是一个能够正常运行、受得了长时间开机的电脑罢了。不过，本站的建立还是比直接把html挂在github page要多出几步的，所谓折腾的乐趣大概就在这里吧（笑）。\n自底向上的Overview # 本次建站中，我选择在本机Arch Linux系统上使用Blowfish主题的Hugo生成网站项目，再将其public文件夹下的网页文件上传至Debian系统的香橙派主机的/var/www/hugo上；香橙派作为服务器，Nginx监听80端口进行静态网页内容的调取，作为反向代理1；Cloudflare建立与服务器的隧道，提供外界访问的接口，作为第二个反向代理；最后，使用Nameslio购买该域名，并将DNS配置为Cloudflare提供的DNS。\n于是，当你的鼠标点击https://hhikr.moe后，上文提到的这些部件就会像一组齿轮一般，反向地连锁运行；而对于目前的这个网站，各种交互只不过是通过这组齿轮，间接地访问服务器中的 html 文件罢了。\n自顶向下的Breakdown # 1. Nameslio: 域名的购买 # 了解的不多，也没什么好说的。正常的.com域名五六十就可以买到，廉价的.xyz/.top域名更是可以夸张到两位数的价格就可以连续租用十年，.moe在 Nameslio 上价格较贵，但价格还是不到一百一年。\n域名也可以在某些网站上免费申请，不过可能面对审核周期长、难以备案等问题。\n2. Cloudflare: 大善人的余裕 # 因为moe而多花几十已经够亏了，再去买个ip地址未免过于破费。而 Cloudflare 正好就可以实现不用自己买公网ip就可以实现外界访问的入站。它主要做了两件事：\n提供 DNS 服务器； 使用 Tunnel 服务，将服务器中的内容通过 Tunnel 向世界敞开。 cloudflare在本机浏览器中的配置几乎都是跟着这个视频来的（跟着做到建立tunnel之前），所以省略具体的配置内容，看视频吧。\n一些科普 # cloudflare是如何做到不需要提供公网ip也能使入站流量导向hhikr.moe?\n当然，不可能做到“不需要ip地址”；cloudflare的tunnel技术提供了所谓的内网出站2的功能。 所谓“内网出站”，就是香橙派像浏览器访问网页一样，自己去连接外部服务器，这种连接在校园网、家庭宽带等没有公网IP的环境下是允许的3，不需要路由器做特殊设置（比如端口映射）。 建立隧道后，Cloudflare服务器就能通过这条香橙派主动打通的通道，把世界各地的访问流量安全地传给香橙派，从而实现即使没有公网IP，网站也可以被所有人访问。\n换句话说，香橙派用 cloudflared 程序， 主动去连接 Cloudflare 的服务器（出站连接）， 这条连接就是一个持久保持的加密通道（Tunnel，隧道）， Cloudflare那边可以通过这条隧道“推送”用户的请求过来。\nCloudflare 为托管的网站免费提供了许多服务，可谓是互联网带善人了，有空会多研究研究。（这算开坑吗？）\n3. Nginx \u0026amp; Orange Pi # 通过ssh服务连接至香橙派主机，在其上进行 Cloudflare 服务、Nginx托管的相关配置。\n连接ssh遇到的问题 # 校园网环境内，服务器的ssh连接遇到了严重的连接问题，并且十分玄学，具体表现是我的主力电脑和手机（使用Termmius软件）都无法连接ssh，舍友的手机秒连， 但是舍友的电脑一样连接不上。但是给香橙派插上主机后连接就没有任何问题了。只能推断是对不同段ip,校园网的管理员配置不一样，因为插网线后内网ip从10开头变成了 172开头（但是主力电脑上的ip一直是10开头）。\n配置流程 # 传输脚本 # 编写脚本，将本地的文件传输至服务器。使用rsync指令，这一部分也是需要ssh的。\n#!/bin/bash # ===================== 配置区 ===================== # DEFAULT_USER=\u0026#34;orangepi\u0026#34; DEFAULT_HOST=\u0026#34;114.514.19.19\u0026#34; REMOTE_DIR=\u0026#34;/var/www/hugo\u0026#34; DEPLOY_LOG=\u0026#34;$HOME/.hugo_deploy.log\u0026#34; URL=\u0026#34;https://hhikr.moe\u0026#34; # ================================================== # echo \u0026#34;🌐 当前配置：\u0026#34; echo \u0026#34;用户：$DEFAULT_USER\u0026#34; echo \u0026#34;IP地址：$DEFAULT_HOST\u0026#34; echo \u0026#34;远程目录：$REMOTE_DIR\u0026#34; echo \u0026#34;\u0026#34; # —— 是否更换 IP 地址？—— read -p \u0026#34;当前的 IP 是 ${DEFAULT_HOST}，是否更换？(y/N): \u0026#34; change_ip if [[ \u0026#34;$change_ip\u0026#34; =~ ^[Yy]$ ]]; then read -p \u0026#34;请输入新的 IP 地址: \u0026#34; new_ip if [[ -n \u0026#34;$new_ip\u0026#34; ]]; then DEFAULT_HOST=\u0026#34;$new_ip\u0026#34; echo \u0026#34;✅ IP 更新为 $DEFAULT_HOST\u0026#34; else echo \u0026#34;⚠️ 未输入新 IP，继续使用默认 IP：$DEFAULT_HOST\u0026#34; fi fi # —— 输入 SSH 密码 —— read -s -p \u0026#34;请输入 SSH 密码（不会显示）: \u0026#34; SSHPASS echo \u0026#34;\u0026#34; echo \u0026#34;\u0026#34; echo \u0026#34;📁 检查远程目录：$REMOTE_DIR\u0026#34; read -p \u0026#34;是否继续部署到该目录？(Y/n): \u0026#34; confirm_dir if [[ \u0026#34;$confirm_dir\u0026#34; =~ ^[Nn]$ ]]; then read -p \u0026#34;请输入新的远程目录路径: \u0026#34; REMOTE_DIR fi echo \u0026#34;🚧 开始构建 Hugo 项目...\u0026#34; hugo 2\u0026gt; hugo-error.log if [ $? -ne 0 ]; then echo \u0026#34;❌ Hugo 构建失败！错误日志保存在 hugo-error.log\u0026#34; exit 1 fi echo \u0026#34;📤 正在上传静态文件到 ${DEFAULT_USER}@${DEFAULT_HOST}:${REMOTE_DIR} ...\u0026#34; sshpass -p \u0026#34;$SSHPASS\u0026#34; rsync -avz --delete -e \u0026#34;ssh -o StrictHostKeyChecking=no\u0026#34; ./public/ ${DEFAULT_USER}@${DEFAULT_HOST}:${REMOTE_DIR} | tee -a \u0026#34;$DEPLOY_LOG\u0026#34; if [ $? -ne 0 ]; then echo \u0026#34;❌ 上传失败！请检查网络或 SSH 权限\u0026#34; exit 1 fi echo \u0026#34;\u0026#34; echo \u0026#34;✅ 部署成功！你的网站应该已经上线：$URL\u0026#34; # —— 是否打开浏览器访问？（仅本机有图形界面时建议开启）—— if command -v xdg-open \u0026amp;\u0026gt; /dev/null; then read -p \u0026#34;是否现在在浏览器中打开网站？(Y/n): \u0026#34; open_browser if [[ ! \u0026#34;$open_browser\u0026#34; =~ ^[Nn]$ ]]; then xdg-open \u0026#34;$URL\u0026#34; fi fi echo \u0026#34;📜 部署日志已记录：$DEPLOY_LOG\u0026#34; 由于我几乎不会写bash脚本，这个脚本是由llm生成的，可能有很奇怪的地方。好在 It just works.\nNginx配置 # 配置Nginx，监听localhost的80端口，托管静态网页。\n# 1. 创建站点目录 sudo mkdir -p /var/www/hugo sudo chown -R $USER:$USER /var/www/hugo # 2. 写入配置 sudo nvim /etc/nginx/sites-available/hugo # 3. 启用配置 sudo ln -s /etc/nginx/sites-available/hugo /etc/nginx/sites-enabled/ # 建立静态连接将“可用网站”放在“已激活网站”下，所以Nginx就会从/etc/nginx/sites-enabled/寻找可以启动的网站。 sudo nginx -t # -t代表test,用于测试Nginx配置是否正确 sudo rm /etc/nginx/sites-enabled/default # 删除默认界面，否则你可能会看到Nginx的默认界面而不是你的网站 sudo systemctl reload nginx # 刷新服务，启动nginx Nginx配置文件实例：\nserver { # 监听端口。为什么是80？因为cloudflare tunnel走的是http！ listen 80; server_name hhikr.moe; root /var/www/hugo; # 首页。 index index.html; # 如果路径存在，返回文件；否则返回 404 location / { try_files $uri $uri/ =404; } } Cloudflare配置 # 安装：根据官方教程安装。下面是官网提供的debian系安装流程。 curl -fsSL https://pkg.cloudflare.com/cloudflare-main.gpg | sudo gpg --dearmor -o /usr/share/keyrings/cloudflare-main.gpg echo \u0026#34;deb [signed-by=/usr/share/keyrings/cloudflare-main.gpg] https://pkg.cloudflare.com/cloudflared bookworm main\u0026#34; | \\ sudo tee /etc/apt/sources.list.d/cloudflared.list sudo apt update sudo apt install cloudflared -y 登陆并创建tunnel # 登录 Cloudflare cloudflared tunnel login # 它会打开一个浏览器链接，在上面登录你的 Cloudflare 账户。 # 创建 tunnel cloudflared tunnel create hhikr-moe-tunnel # 会生成一个 .json 文件，路径如 /home/orangepi/.cloudflared/634b00...json 配置 Cloudflare Tunnel，映射到本地 Nginx mkdir -p ~/.cloudflared nano ~/.cloudflared/config.yml 配置文件这么写：\ntunnel: hhikr-moe-tunnel credentials-file: /home/orangepi/.cloudflared/634b00...json ingress: - hostname: hhikr.moe service: http://localhost:80 - service: http_status:404 将tunnel与域名绑定，并启动tunnel cloudflared tunnel route dns hhikr-moe-tunnel hhikr.moe # 暂时启动，有输出，用于查看运行状态或debug cloudflared tunnel run hhikr-moe-tunnel # 永久启动，作为service运行，开机就会自动运行。 sudo cloudflared service install 至此，网站应该就可以正常运作了。おめでとう🎉\n反向代理是一种服务器，它位于客户端和目标服务器之间，客户端以为自己直接连接的是目标服务器，但实际上所有请求都先到反向代理，由它再转发到真正的服务器；这样可以隐藏真实服务器地址、实现负载均衡、缓存内容，加速访问，提高安全性。\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n在网络通信里，出站（Outbound）指的是从你的设备主动发起请求到外部，入站（Inbound）指的是外部主动连接到你的设备。\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n没有公网ip的设备可以进行出站访问，但不能处理入站请求。\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n","date":"2025 April 28","externalUrl":null,"permalink":"/posts/building-website/","section":"Posts","summary":"第一次建站的一些经验。","title":"记录我的第一次建站","type":"posts"},{"content":"","date":"2025 April 28","externalUrl":null,"permalink":"/tags/%E5%BB%BA%E7%AB%99/","section":"Tags","summary":"","title":"建站","type":"tags"},{"content":"","date":"2025 April 28","externalUrl":null,"permalink":"/tags/%E9%A6%99%E6%A9%99%E6%B4%BE/","section":"Tags","summary":"","title":"香橙派","type":"tags"},{"content":"hey! (招手.gif)1\n早就想做个人网站了，但是一直摆着……不过还是做出来了，感谢朋友半天建站完成的push喵。\n软件工程二年生，正在被编译原理折磨。可能什么文章都会放网站上,专业/语言/音乐的学习笔记、观影杂谈、或者是捣鼓一些自己感兴趣的东西，比如尝试不同的linux发行版和桌面环境、捣鼓网站新功能之类\n这篇文章将会是一个时间胶囊，记录网站在今后的沿革。目前网站还在测试阶段，并没有什么有趣的东西，预计劳动节会做个差不多。所以首先，来看看我建站都用了哪些相关的技术栈吧（超简单的来着）。\n第一次修改，ver 0.20250428\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n","date":"2025 April 28","externalUrl":null,"permalink":"/posts/time-machine/","section":"Posts","summary":"引导之始。","title":"时间胶囊","type":"posts"},{"content":"","externalUrl":null,"permalink":"/authors/","section":"Authors","summary":"","title":"Authors","type":"authors"}]